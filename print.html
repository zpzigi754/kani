<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Kani Rust Verifier</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Kani Rust Verifier">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install-guide.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="build-from-source.html"><strong aria-hidden="true">1.1.1.</strong> Building from source</a></li><li class="chapter-item expanded "><a href="install-github-ci.html"><strong aria-hidden="true">1.1.2.</strong> GitHub CI Action</a></li></ol></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">1.2.</strong> Using Kani</a></li><li class="chapter-item expanded "><a href="verification-results.html"><strong aria-hidden="true">1.3.</strong> Verification results</a></li></ol></li><li class="chapter-item expanded "><a href="kani-tutorial.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial-first-steps.html"><strong aria-hidden="true">2.1.</strong> First steps</a></li><li class="chapter-item expanded "><a href="tutorial-kinds-of-failure.html"><strong aria-hidden="true">2.2.</strong> Failures that Kani can spot</a></li><li class="chapter-item expanded "><a href="tutorial-loop-unwinding.html"><strong aria-hidden="true">2.3.</strong> Loop unwinding</a></li><li class="chapter-item expanded "><a href="tutorial-nondeterministic-variables.html"><strong aria-hidden="true">2.4.</strong> Nondeterministic variables</a></li><li class="chapter-item expanded "><a href="debugging-verification-failures.html"><strong aria-hidden="true">2.5.</strong> Debugging verification failures</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">3.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/attributes.html"><strong aria-hidden="true">3.1.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="reference/stubbing.html"><strong aria-hidden="true">3.2.</strong> Stubbing</a></li></ol></li><li class="chapter-item expanded "><a href="application.html"><strong aria-hidden="true">4.</strong> Application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tool-comparison.html"><strong aria-hidden="true">4.1.</strong> Comparison with other tools</a></li><li class="chapter-item expanded "><a href="tutorial-real-code.html"><strong aria-hidden="true">4.2.</strong> Where to start on real code</a></li></ol></li><li class="chapter-item expanded "><a href="dev-documentation.html"><strong aria-hidden="true">5.</strong> Developer documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conventions.html"><strong aria-hidden="true">5.1.</strong> Coding conventions</a></li><li class="chapter-item expanded "><a href="cbmc-hacks.html"><strong aria-hidden="true">5.2.</strong> Working with CBMC</a></li><li class="chapter-item expanded "><a href="rustc-hacks.html"><strong aria-hidden="true">5.3.</strong> Working with rustc</a></li><li class="chapter-item expanded "><a href="stable-mir.html"><strong aria-hidden="true">5.4.</strong> Migrating to StableMIR</a></li><li class="chapter-item expanded "><a href="cheat-sheets.html"><strong aria-hidden="true">5.5.</strong> Command cheat sheets</a></li><li class="chapter-item expanded "><a href="dev-assess.html"><strong aria-hidden="true">5.6.</strong> cargo kani assess</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">5.7.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="regression-testing.html"><strong aria-hidden="true">5.7.1.</strong> Regression testing</a></li><li class="chapter-item expanded "><a href="bookrunner.html"><strong aria-hidden="true">5.7.2.</strong> Book runner</a></li><li class="chapter-item expanded "><a href="repo-crawl.html"><strong aria-hidden="true">5.7.3.</strong> (Experimental) Testing with a Large Number of Repositories</a></li></ol></li><li class="chapter-item expanded "><a href="performance-comparisons.html"><strong aria-hidden="true">5.8.</strong> Performance comparisons</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="benchcomp-cli.html"><strong aria-hidden="true">5.8.1.</strong> benchcomp command line</a></li><li class="chapter-item expanded "><a href="benchcomp-conf.html"><strong aria-hidden="true">5.8.2.</strong> benchcomp configuration file</a></li><li class="chapter-item expanded "><a href="benchcomp-parse.html"><strong aria-hidden="true">5.8.3.</strong> Custom parsers</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="limitations.html"><strong aria-hidden="true">6.</strong> Limitations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="undefined-behaviour.html"><strong aria-hidden="true">6.1.</strong> Undefined behaviour</a></li><li class="chapter-item expanded "><a href="rust-feature-support.html"><strong aria-hidden="true">6.2.</strong> Rust feature support</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-feature-support/intrinsics.html"><strong aria-hidden="true">6.2.1.</strong> Intrinsics</a></li><li class="chapter-item expanded "><a href="rust-feature-support/unstable.html"><strong aria-hidden="true">6.2.2.</strong> Unstable features</a></li></ol></li><li class="chapter-item expanded "><a href="overrides.html"><strong aria-hidden="true">6.3.</strong> Overrides</a></li></ol></li><li class="chapter-item expanded "><a href="crates/index.html"><strong aria-hidden="true">7.</strong> Crates Documentation</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">8.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Kani Rust Verifier</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/model-checking/kani" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Kani is an open-source verification tool that uses <a href="./tool-comparison.html">model checking</a> to analyze Rust programs.
Kani is particularly useful for verifying unsafe code blocks in Rust, where the &quot;<a href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html#unsafe-superpowers">unsafe superpowers</a>&quot; are unchecked by the compiler.
Some example properties you can prove with Kani include memory safety properties (e.g., null pointer dereferences, use-after-free, etc.), the absence of certain runtime errors (i.e., index out of bounds, panics), and the absence of some types of unexpected behavior (e.g., arithmetic overflows).
Kani can also prove custom properties provided in the form of user-specified assertions.
As Kani uses model checking, Kani will either prove the property, disprove the
property (with a counterexample), or may run out of resources.</p>
<p>Kani uses proof harnesses to analyze programs.
Proof harnesses are similar to test harnesses, especially property-based test harnesses.</p>
<h2 id="project-status"><a class="header" href="#project-status">Project Status</a></h2>
<p>Kani is currently under active development.
Releases are published <a href="https://github.com/model-checking/kani/releases">here</a>.
Major changes to Kani are documented in the <a href="https://model-checking.github.io/kani/rfc">RFC Book</a>.</p>
<p>There is support for a fair amount of Rust language features, but not all (e.g., concurrency).
Please see <a href="./limitations.html">Limitations</a> for a detailed list of supported features.</p>
<p>Kani releases every two weeks.
As part of every release, Kani will synchronize with a recent nightly release of Rust, and so is generally up-to-date with the latest Rust language features.</p>
<p>If you encounter issues when using Kani, we encourage you to <a href="https://github.com/model-checking/kani/issues/new/choose">report them to us</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Kani offers an easy installation option on three platforms:</p>
<ul>
<li><code>x86_64-unknown-linux-gnu</code> (Most Linux distributions)</li>
<li><code>x86_64-apple-darwin</code> (Intel Mac OS)</li>
<li><code>aarch64-apple-darwin</code> (Apple Silicon Mac OS)</li>
</ul>
<p>Other platforms are either not yet supported or require instead that
you <a href="build-from-source.html">build from source</a>. To use Kani in your
GitHub CI workflows, see <a href="./install-github-ci.html">GitHub CI Action</a>.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>The following must already be installed:</p>
<ul>
<li><strong>Python version 3.7 or newer</strong> and the package installer <code>pip</code>.</li>
<li>Rust 1.58 or newer installed via <code>rustup</code>.</li>
<li><code>ctags</code> is required for Kani's <code>--visualize</code> option to work correctly. <a href="https://ctags.io/">Universal ctags</a> is recommended.</li>
</ul>
<h2 id="installing-the-latest-version"><a class="header" href="#installing-the-latest-version">Installing the latest version</a></h2>
<p>To install the latest version of Kani, run:</p>
<pre><code class="language-bash">cargo install --locked kani-verifier
cargo kani setup
</code></pre>
<p>This will build and place in <code>~/.cargo/bin</code> (in a typical environment) the <code>kani</code> and <code>cargo-kani</code> binaries.
The second step (<code>cargo kani setup</code>) will download the Kani compiler and other necessary dependencies, and place them under <code>~/.kani/</code> by default.
A custom path can be specified using the <code>KANI_HOME</code> environment variable.</p>
<h2 id="installing-an-older-version"><a class="header" href="#installing-an-older-version">Installing an older version</a></h2>
<pre><code class="language-bash">cargo install --locked kani-verifier --version &lt;VERSION&gt;
cargo kani setup
</code></pre>
<h2 id="checking-your-installation"><a class="header" href="#checking-your-installation">Checking your installation</a></h2>
<p>After you've installed Kani,
you can try running it by creating a test file:</p>
<pre><code class="language-rust">// File: test.rs
#[kani::proof]
fn main() {
    assert!(1 == 2);
}
</code></pre>
<p>Run Kani on the single file:</p>
<pre><code>kani test.rs
</code></pre>
<p>You should get a result like this one:</p>
<pre><code>[...]
RESULTS:
Check 1: main.assertion.1
         - Status: FAILURE
         - Description: &quot;assertion failed: 1 == 2&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p>Fix the test and you should see a result like this one:</p>
<pre><code>[...]
VERIFICATION:- SUCCESSFUL
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>If you're learning Kani for the first time, you may be interested in our <a href="kani-tutorial.html">tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-from-source-code"><a class="header" href="#installing-from-source-code">Installing from source code</a></h1>
<blockquote>
<p>If you were able to <a href="install-guide.html">install Kani</a> normally, you do not need to build Kani from source.
You probably want to proceed to the <a href="kani-tutorial.html">Kani tutorial</a>.</p>
</blockquote>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<p>In general, the following dependencies are required to build Kani from source.</p>
<blockquote>
<p><strong>NOTE</strong>: These dependencies may be installed by running the scripts shown
below and don't need to be manually installed.</p>
</blockquote>
<ol>
<li>Cargo installed via <a href="https://rustup.rs/">rustup</a></li>
<li><a href="https://github.com/diffblue/cbmc">CBMC</a> (latest release)</li>
<li><a href="https://github.com/awslabs/aws-viewer-for-cbmc">CBMC Viewer</a> (latest release)</li>
<li><a href="https://github.com/arminbiere/kissat">Kissat</a> (Release 3.1.1)</li>
</ol>
<p>Kani has been tested in <a href="build-from-source.html#install-dependencies-on-ubuntu">Ubuntu</a> and <a href="build-from-source.html##install-dependencies-on-macos">macOS</a> platforms.</p>
<h3 id="install-dependencies-on-ubuntu"><a class="header" href="#install-dependencies-on-ubuntu">Install dependencies on Ubuntu</a></h3>
<p>Support is available for Ubuntu 18.04, 20.04 and 22.04.
The simplest way to install dependencies (especially if you're using a fresh VM)
is following our CI scripts:</p>
<pre><code># git clone git@github.com:model-checking/kani.git
git clone https://github.com/model-checking/kani.git
cd kani
git submodule update --init
./scripts/setup/ubuntu/install_deps.sh
# If you haven't already (or from https://rustup.rs/):
./scripts/setup/install_rustup.sh
source $HOME/.cargo/env
</code></pre>
<h3 id="install-dependencies-on-macos"><a class="header" href="#install-dependencies-on-macos">Install dependencies on macOS</a></h3>
<p>Support is available for macOS 11. You need to have <a href="https://brew.sh/">Homebrew</a> installed already.</p>
<pre><code># git clone git@github.com:model-checking/kani.git
git clone https://github.com/model-checking/kani.git
cd kani
git submodule update --init
./scripts/setup/macos/install_deps.sh
# If you haven't already (or from https://rustup.rs/):
./scripts/setup/install_rustup.sh
source $HOME/.cargo/env
</code></pre>
<h2 id="build-and-test-kani"><a class="header" href="#build-and-test-kani">Build and test Kani</a></h2>
<p>Build the Kani package:</p>
<pre><code>cargo build-dev
</code></pre>
<p>Then, optionally, run the regression tests:</p>
<pre><code>./scripts/kani-regression.sh
</code></pre>
<p>This script has a lot of noisy output, but on a successful run you'll see at the end of the execution:</p>
<pre><code>All Kani regression tests completed successfully.
</code></pre>
<h2 id="adding-kani-to-your-path"><a class="header" href="#adding-kani-to-your-path">Adding Kani to your path</a></h2>
<p>To use a locally-built Kani from anywhere, add the Kani scripts to your path:</p>
<pre><code class="language-bash">export PATH=$(pwd)/scripts:$PATH
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next steps</a></h2>
<p>If you're learning Kani for the first time, you may be interested in our <a href="kani-tutorial.html">tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-action"><a class="header" href="#github-action">GitHub Action</a></h1>
<p>Kani offers a GitHub Action for running Kani in CI.
As of now, only Ubuntu 20.04 with <code>x86_64-unknown-linux-gnu</code> is supported for Kani in CI.</p>
<h2 id="using-kani-in-your-github-workflow"><a class="header" href="#using-kani-in-your-github-workflow">Using Kani in your GitHub workflow</a></h2>
<p>Our GitHub Action is available in the <a href="https://github.com/marketplace/actions/kani-rust-verifier">GitHub Marketplace</a>.</p>
<p>The following workflow snippet will checkout your repository and run <code>cargo kani</code> on it whenever a push or pull request occurs.
Replace <code>&lt;MAJOR&gt;.&lt;MINOR&gt;</code> with the version of Kani you want to run with.</p>
<pre><code class="language-yaml">name: Kani CI
on:
  pull_request:
  push:
jobs:
  run-kani:
    runs-on: ubuntu-20.04
    steps:
      - name: 'Checkout your code.'
        uses: actions/checkout@v3

      - name: 'Run Kani on your code.'
        uses: model-checking/kani-github-action@v&lt;MAJOR&gt;.&lt;MINOR&gt;
</code></pre>
<p>This will run <code>cargo kani</code> on the code you checked out.</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p>The action takes the following optional parameters:</p>
<ul>
<li><code>command</code>: The command to run. 
Defaults to <code>cargo kani</code>.
Most often, you will not need to change this.</li>
<li><code>working-directory</code>: The directory to execute the command in.
Defaults to <code>.</code>.
Useful if your repository has multiple crates, and you only want to run on one of them.</li>
<li><code>args</code>: The arguments to pass to the given <code>${command}</code>.
See <code>cargo kani --help</code> for a full list of options.
Useful options include:
<ul>
<li><code>--output-format=terse</code> to generate terse output.</li>
<li><code>--tests</code> to run on proofs inside the <code>test</code> module (needed for running Bolero).</li>
<li><code>--workspace</code> to run on all crates within your repository.</li>
</ul>
</li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<ul>
<li><strong>Kani takes too long for my CI</strong>: Try running Kani on a
<a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule">schedule</a>
with desired frequency.</li>
<li><strong>Kani Silently Crashes with no logs</strong>: Few possible reasons:
<ul>
<li>Kani ran out of RAM. GitHub offers up to 7GB of RAM, but Kani may
use more. Run locally to confirm.</li>
<li>GitHub terminates jobs longer than 6 hours.</li>
<li>Otherwise, consider filing an issue <a href="https://github.com/model-checking/kani/issues">here</a>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-kani"><a class="header" href="#using-kani">Using Kani</a></h1>
<p>At present, Kani can used in two ways:</p>
<ul>
<li><a href="usage.html#usage-on-a-single-crate">On a single crate</a> with the <code>kani</code> command.</li>
<li><a href="usage.html#usage-on-a-package">On a Cargo package</a> with the <code>cargo kani</code> command.</li>
</ul>
<p>If you plan to integrate Kani in your projects, the recommended approach is to use <code>cargo kani</code>.
If you're already using cargo, this will handle dependencies automatically, and it can be configured (if needed) in <code>Cargo.toml</code>.
But <code>kani</code> is useful for small examples/tests.</p>
<h2 id="usage-on-a-package"><a class="header" href="#usage-on-a-package">Usage on a package</a></h2>
<p>Kani is integrated with <code>cargo</code> and can be invoked from a package as follows:</p>
<pre><code class="language-bash">cargo kani [OPTIONS]
</code></pre>
<p>This works like <code>cargo test</code> except that it will analyze all proof harnesses instead of running all test harnesses.</p>
<h2 id="common-command-line-flags"><a class="header" href="#common-command-line-flags">Common command line flags</a></h2>
<p>Common to both <code>kani</code> and <code>cargo kani</code> are many command-line flags:</p>
<ul>
<li>
<p><code>--concrete-playback=[print|inplace]</code>: <em>Experimental</em>, <code>--enable-unstable</code> feature that generates a Rust unit test case
that plays back a failing proof harness using a concrete counterexample.
If used with <code>print</code>, Kani will only print the unit test to stdout.
If used with <code>inplace</code>, Kani will automatically add the unit test to the user's source code, next to the proof harness. For more detailed instructions, see the <a href="./debugging-verification-failures.html">debugging verification failures</a> section.</p>
</li>
<li>
<p><code>--visualize</code>: <em>Experimental</em>, <code>--enable-unstable</code> feature that generates an HTML report providing traces (i.e., counterexamples) for each failure found by Kani.</p>
</li>
<li>
<p><code>--tests</code>: Build in &quot;<a href="https://doc.rust-lang.org/rustc/tests/index.html">test mode</a>&quot;, i.e. with <code>cfg(test)</code> set and <code>dev-dependencies</code> available (when using <code>cargo kani</code>).</p>
</li>
<li>
<p><code>--harness &lt;name&gt;</code>: By default, Kani checks all proof harnesses it finds.
You can switch to checking a single harness using this flag.</p>
</li>
<li>
<p><code>--default-unwind &lt;n&gt;</code>: Set a default global upper <a href="./tutorial-loop-unwinding.html">loop unwinding</a> bound for proof harnesses.
This can force termination when CBMC tries to unwind loops indefinitely.</p>
</li>
</ul>
<p>Run <code>cargo kani --help</code> to see a complete list of arguments.</p>
<h2 id="usage-on-a-single-crate"><a class="header" href="#usage-on-a-single-crate">Usage on a single crate</a></h2>
<p>For small examples or initial learning, it's very common to run Kani on just one source file.
The command line format for invoking Kani directly is the following:</p>
<pre><code>kani filename.rs [OPTIONS]
</code></pre>
<p>This will build <code>filename.rs</code> and run all proof harnesses found within.</p>
<h2 id="configuration-in-cargotoml"><a class="header" href="#configuration-in-cargotoml">Configuration in <code>Cargo.toml</code></a></h2>
<p>Users can add a default configuration to the <code>Cargo.toml</code> file for running harnesses in a package.
Kani will extract any arguments from these sections:</p>
<ul>
<li><code>[workspace.metadata.kani.flags]</code></li>
<li><code>[package.metadata.kani.flags]</code></li>
</ul>
<p>For example, if you want to set a default loop unwinding bound (when it's not otherwise specified), you can achieve this by adding the following lines to the package's <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.kani.flags]
default-unwind = 1
</code></pre>
<p>The options here are the same as on the command line (<code>cargo kani --help</code>), and flags (that is, command line arguments that don't take a value) are enabled by setting them to <code>true</code>.</p>
<h2 id="the-build-process"><a class="header" href="#the-build-process">The build process</a></h2>
<p>When Kani builds your code, it does two important things:</p>
<ol>
<li>It sets <code>cfg(kani)</code>.</li>
<li>It injects the <code>kani</code> crate.</li>
</ol>
<p>A proof harness (which you can <a href="./kani-tutorial.html">learn more about in the tutorial</a>), is a function annotated with <code>#[kani::proof]</code> much like a test is annotated with <code>#[test]</code>.
But you may experience a similar problem using Kani as you would with <code>dev-dependencies</code>: if you try writing <code>#[kani::proof]</code> directly in your code, <code>cargo build</code> will fail because it doesn't know what the <code>kani</code> crate is.</p>
<p>This is why we recommend the same conventions as are used when writing tests in Rust: wrap your proof harnesses in <code>cfg(kani)</code> conditional compilation:</p>
<pre><code class="language-rust">#[cfg(kani)]
mod verification {
    use super::*;

    #[kani::proof]
    pub fn check_something() {
        // ....
    }
}
</code></pre>
<p>This will ensure that a normal build of your code will be completely unaffected by anything Kani-related.</p>
<p>This conditional compilation with <code>cfg(kani)</code> (as seen above) is still required for Kani proofs placed under <code>tests/</code>.
When this code is built by <code>cargo test</code>, the <code>kani</code> crate is not available, and so it would otherwise cause build failures.
(Whereas the use of <code>dev-dependencies</code> under <code>tests/</code> does not need to be gated with <code>cfg(test)</code> since that code is already only built when testing.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verification-results"><a class="header" href="#verification-results">Verification results</a></h1>
<p>Running Kani on a harness produces an output that includes a set of checks as
follows:</p>
<pre><code>RESULTS:
Check 1: example.assertion.1
         - Status: &lt;status&gt;
         - Description: &lt;description&gt;
         - Location: &lt;location&gt;
[...]
</code></pre>
<p>Kani determines the verification result for the harness based on the
result (i.e., <code>&lt;status&gt;</code>) of each individual check (also known as &quot;properties&quot;). If all
checks are successful then the overall verification result of the harness is successful. Otherwise the
verification fails, which indicates issues with the code under verification.</p>
<h2 id="check-results"><a class="header" href="#check-results">Check results</a></h2>
<p>The result (or <code>Status</code>) of a check in Kani can be one of the following:</p>
<ol>
<li><code>SUCCESS</code>: This indicates that the check passed (i.e., the property holds).
Note that in some cases, the property may hold <em>vacuously</em>. This can occur
because the property is unreachable, or because the harness is
<em>over-constrained</em>.</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn success_example() {
    let mut sum = 0;
    for i in 1..4 {
        sum += i;
    }
    assert_eq!(sum, 6);
}
</code></pre>
<p>The output from Kani indicates that the assertion holds:</p>
<pre><code>Check 4: success_example.assertion.4
         - Status: SUCCESS
         - Description: &quot;assertion failed: sum == 6&quot;
</code></pre>
<ol start="2">
<li><code>FAILURE</code>: This indicates that the check failed (i.e., the property doesn't
hold). In this case, please see the <a href="./debugging-verification-failures.html">debugging verification failures</a>
section for more help.</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn failure_example() {
    let arr = [1, 2, 3];
    assert_ne!(arr.len(), 3);
}
</code></pre>
<p>The assertion doesn't hold as Kani's output indicates:</p>
<pre><code>Check 2: failure_example.assertion.2
         - Status: FAILURE
         - Description: &quot;assertion failed: arr.len() != 3&quot;
</code></pre>
<ol start="3">
<li><code>UNREACHABLE</code>: This indicates that the check is unreachable (i.e., the
property holds <em>vacuously</em>). This occurs when there is no possible execution
trace that can reach the check's line of code.
This may be because the function that contains the check is unused, or because
the harness does not trigger the condition under which the check is invoked.
Kani currently checks reachability for the following assertion types:
<ol>
<li>Assert macros (e.g. <code>assert</code>, <code>assert_eq</code>, etc.)</li>
<li>Arithmetic overflow checks</li>
<li>Negation overflow checks</li>
<li>Index out-of-bounds checks</li>
<li>Divide/remainder-by-zero checks</li>
</ol>
</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn unreachable_example() {
    let x = 5;
    let y = x + 2;
    if x &gt; y {
        assert!(x &lt; 8);
    }
}
</code></pre>
<p>The output from Kani indicates that the assertion is unreachable:</p>
<pre><code>Check 2: unreachable_example.assertion.2
         - Status: UNREACHABLE
         - Description: &quot;assertion failed: x &lt; 8&quot;
</code></pre>
<ol start="4">
<li><code>UNDETERMINED</code>: This indicates that Kani was not able to conclude whether the
property holds or not. This can occur when the Rust program contains a construct
that is not currently supported by Kani. See
<a href="./rust-feature-support.html">Rust feature support</a> for Kani's current support of the
Rust language features.</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn undetermined_example() {
    let mut x = 0;
    unsupp(&amp;mut x);
    assert!(x == 0);
}

#[feature(asm)]
fn unsupp(x: &amp;mut u8) {
    unsafe {
        std::arch::asm!(&quot;nop&quot;);
    }
}

</code></pre>
<p>The output from Kani indicates that the assertion is undetermined due to the
missing support for inline assembly in Kani:</p>
<pre><code>Check 2: undetermined_example.assertion.2
         - Status: UNDETERMINED
         - Description: &quot;assertion failed: x == 0&quot;
</code></pre>
<h2 id="cover-property-results"><a class="header" href="#cover-property-results">Cover property results</a></h2>
<p>Kani provides a <a href="https://model-checking.github.io/kani/crates/doc/kani/macro.cover.html"><code>kani::cover</code></a> macro that can be used for checking whether a condition may occur at a certain point in the code.</p>
<p>The result of a cover property can be one of the following:</p>
<ol>
<li><code>SATISFIED</code>: This indicates that Kani found an execution that triggers the specified condition.</li>
</ol>
<p>The following example uses <code>kani::cover</code> to check if it's possible for <code>x</code> and <code>y</code> to hold the values 24 and 72, respectively, after 3 iterations of the <code>while</code> loop, which turns out to be the case.</p>
<pre><code class="language-rust">#[kani::unwind(256)]
fn cover_satisfied_example() {
    let mut x: u8 = kani::any();
    let mut y: u8 = kani::any();
    y /= 2;
    let mut i = 0;
    while x != 0 &amp;&amp; y != 0 {
        kani::cover!(i &gt; 2 &amp;&amp; x == 24 &amp;&amp; y == 72);
        if x &gt;= y { x -= y; }
        else { y -= x; }
        i += 1;
    }
}
</code></pre>
<p>Results:</p>
<pre><code>Check 1: cover_satisfied_example.cover.1
         - Status: SATISFIED
         - Description: &quot;cover condition: i &gt; 2 &amp;&amp; x == 24 &amp;&amp; y == 72&quot;
         - Location: src/main.rs:60:9 in function cover_satisfied_example
</code></pre>
<ol start="2">
<li><code>UNSATISFIABLE</code>: This indicates that Kani <em>proved</em> that the specified condition is impossible.</li>
</ol>
<p>The following example uses <code>kani::cover</code> to check if it's possible to have a UTF-8 encoded string consisting of 5 bytes that correspond to a string with a single character.</p>
<pre><code class="language-rust">#[kani::unwind(6)]
fn cover_unsatisfiable_example() {
    let bytes: [u8; 5] = kani::any();
    let s = std::str::from_utf8(&amp;bytes);
    if let Ok(s) = s {
        kani::cover!(s.chars().count() &lt;= 1);
    }
}
</code></pre>
<p>which is not possible as such string will contain at least two characters.</p>
<pre><code>Check 46: cover_unsatisfiable_example.cover.1
         - Status: UNSATISFIABLE
         - Description: &quot;cover condition: s.chars().count() &lt;= 1&quot;
         - Location: src/main.rs:75:9 in function cover_unsatisfiable_example
</code></pre>
<ol start="3">
<li><code>UNREACHABLE</code>: This indicates that the <code>cover</code> property itself is unreachable (i.e. it is <em>vacuously</em> unsatisfiable).</li>
</ol>
<p>In contrast to an <code>UNREACHABLE</code> result for assertions, an unreachable (or an unsatisfiable) cover property may indicate an incomplete proof.</p>
<p>Example:
In this example, a <code>kani::cover</code> call is unreachable because if the outer <code>if</code> condition holds, then the non-empty range <code>r2</code> is strictly larger than the non-empty range <code>r1</code>, in which case, the condition in the inner <code>if</code> condition is impossible.</p>
<pre><code class="language-rust">#[kani::unwind(6)]
fn cover_unreachable_example() {
    let r1: std::ops::Range&lt;i32&gt; = kani::any()..kani::any();
    let r2: std::ops::Range&lt;i32&gt; = kani::any()..kani::any();
    kani::assume(!r1.is_empty());
    kani::assume(!r2.is_empty());
    if r2.start &gt; r1.end {
        if r2.end &lt; r1.end {
            kani::cover!(r2.contains(&amp;0));
        }
    }
}
</code></pre>
<pre><code>Check 3: cover_unreachable_example.cover.1
         - Status: UNREACHABLE
         - Description: &quot;cover condition: r2.contains(&amp;0)&quot;
         - Location: src/main.rs:90:13 in function cover_unreachable_example
</code></pre>
<ol start="4">
<li><code>UNDETERMINED</code>: This is the same as the <code>UNDETERMINED</code> result for normal checks (see [check_results]).</li>
</ol>
<h2 id="verification-summary"><a class="header" href="#verification-summary">Verification summary</a></h2>
<p>Kani reports a summary at the end of the verification report, which includes the overall results of all checks, the overall results of cover properties (if the package includes cover properties), and the overall verification result, e.g.:</p>
<pre><code>SUMMARY:
 ** 0 of 786 failed (41 unreachable)

 ** 0 of 1 cover properties satisfied


VERIFICATION:- SUCCESSFUL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<blockquote>
<p><strong>NOTE</strong>: This tutorial expects you to have followed the Kani <a href="./install-guide.html">installation instructions</a> first.</p>
</blockquote>
<p>This tutorial will step you through a progression from simple to moderately complex tasks with Kani.
It's meant to ensure you can get started, and see at least some simple examples of how typical proofs are structured.
It will also teach you the basics of &quot;debugging&quot; proof harnesses, which mainly consists of diagnosing and resolving non-termination issues with the solver.</p>
<p>You may also want to read the <a href="./application.html">Application</a> section to better
understand what Kani is and how it can be applied on real code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-steps"><a class="header" href="#first-steps">First steps</a></h1>
<p>Kani is unlike the testing tools you may already be familiar with.
Much of testing is concerned with thinking of new corner cases that need to be covered.
With Kani, all the corner cases are covered from the start, and the new concern is narrowing down the scope to something manageable for the verifier.</p>
<p>Consider this first program (which can be found under <a href="https://github.com/model-checking/kani/tree/main/docs/src/tutorial/first-steps-v1/"><code>first-steps-v1</code></a>):</p>
<pre><code class="language-rust">fn estimate_size(x: u32) -&gt; u32 {
    if x &lt; 256 {
        if x &lt; 128 {
            return 1;
        } else {
            return 3;
        }
    } else if x &lt; 1024 {
        if x &gt; 1022 {
            panic!(&quot;Oh no, a failing corner case!&quot;);
        } else {
            return 5;
        }
    } else {
        if x &lt; 2048 {
            return 7;
        } else {
            return 9;
        }
    }
}
</code></pre>
<p>Think about the test harness you would need to write to test this function.
You would need figure out a whole set of arguments to call the function with that would exercise each branch.
You would also need to keep that test harness up-to-date with the code, in case some of the branches change.
And if this function was more complicated—for example, if some of the branches depended on global state—the test harness would be even more onerous to write.</p>
<p>We can try to property test a function like this, but if we're naive about it (and consider all possible <code>u32</code> inputs), then it's unlikely we'll ever find the bug.</p>
<pre><code class="language-rust">    proptest! {
        #![proptest_config(ProptestConfig::with_cases(10000))]
        #[test]
        fn doesnt_crash(x: u32) {
            estimate_size(x);
        }
    }
</code></pre>
<pre><code># cargo test
[...]
test tests::doesnt_crash ... ok
</code></pre>
<p>There's only 1 in 4 billion inputs that fail, so it's vanishingly unlikely the property test will find it, even with a million samples.</p>
<p>Let's write a Kani <a href="reference/attributes.html#kaniproof"><em>proof harness</em></a> for <code>estimate_size</code>.
This is a lot like a test harness, but now we can use <code>kani::any()</code> to represent all possible <code>u32</code> values:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn check_estimate_size() {
    let x: u32 = kani::any();
    estimate_size(x);
}
</code></pre>
<pre><code># cargo kani
[...]
Runtime decision procedure: 0.00116886s

RESULTS:
Check 3: estimate_size.assertion.1
         - Status: FAILURE
         - Description: &quot;Oh no, a failing corner case!&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p>Kani has immediately found a failure.
Notably, we haven't had to write explicit assertions in our proof harness: by default, Kani will find a host of erroneous conditions which include a reachable call to <code>panic</code> or a failing <code>assert</code>.
If Kani had run successfully on this harness, this amounts to a mathematical proof that there is no input that could cause a panic in <code>estimate_size</code>.</p>
<h3 id="getting-a-trace"><a class="header" href="#getting-a-trace">Getting a trace</a></h3>
<p>By default, Kani only reports failures, not how the failure happened.
In this running example, it seems obvious what we're interested in (the value of <code>x</code> that caused the failure) because we just have one unknown input at the start (similar to the property test), but that's kind of a special case.
In general, understanding how a failure happened requires exploring a full (potentially large) <em>execution trace</em>.</p>
<p>An execution trace is a record of exactly how a failure can occur.
Nondeterminism (like a call to <code>kani::any()</code>, which could return any value) can appear in the middle of its execution.
A trace is a record of exactly how execution proceeded, including concrete choices (like <code>1023</code>) for all of these nondeterministic values.</p>
<p>To get a trace for a failing check in Kani, run:</p>
<pre><code>cargo kani --visualize --enable-unstable
</code></pre>
<p>This command runs Kani and generates an HTML report that includes a trace.
Open the report with your preferred browser.
Under the &quot;Errors&quot; heading, click on the &quot;trace&quot; link to find the trace for this failure.</p>
<p>From this trace report, we can filter through it to find relevant lines.
A good rule of thumb is to search for either <code>kani::any()</code> or assignments to variables you're interested in.
At present time, an unfortunate amount of generated code is present in the trace.
This code isn't a part of the Rust code you wrote, but is an internal implementation detail of how Kani runs proof harnesses.
Still, searching for <code>kani::any()</code> quickly finds us these lines:</p>
<pre><code>let x: u32 = kani::any();
x = 1023u
</code></pre>
<p>Here we're seeing the line of code and the value assigned in this particular trace.
Like property testing, this is just one <strong>example</strong> of a failure.
To proceed, we recommend fixing the code to avoid this particular issue and then re-running Kani to see if you find more issues.</p>
<h3 id="exercise-try-other-failures"><a class="header" href="#exercise-try-other-failures">Exercise: Try other failures</a></h3>
<p>We put an explicit panic in this function, but it's not the only kind of failure Kani will find.
Try a few other types of errors.</p>
<p>For example, instead of panicking we could try explicitly dereferencing a null pointer:</p>
<pre><code class="language-rust">unsafe { return *(0 as *const u32) };
</code></pre>
<p>Notably, however, the Rust compiler emits a warning here:</p>
<pre><code>warning: dereferencing a null pointer
  --&gt; src/lib.rs:10:29
   |
10 |    unsafe { return *(0 as *const u32) };
   |                    ^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed
   |
   = note: `#[warn(deref_nullptr)]` on by default
</code></pre>
<p>Still, it's just a warning, and we can run the code without test failures just as before.
But Kani still catches the issue:</p>
<pre><code>[...]
RESULTS:
[...]
Check 2: estimate_size.pointer_dereference.1
         - Status: FAILURE
         - Description: &quot;dereference failure: pointer NULL&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p><strong>Exercise: Can you find an example where the Rust compiler will not complain, and Kani will?</strong></p>
<details>
<summary>Click to show one possible answer</summary>
<pre><code>return 1 &lt;&lt; x;
</code></pre>
<p>Overflow (in addition, multiplication or, in this case, <a href="https://github.com/rust-lang/rust/issues/10183">bit-shifting by too much</a>) is also caught by Kani:</p>
<pre><code>RESULTS:
[...]
Check 1: estimate_size.assertion.1
         - Status: FAILURE
         - Description: &quot;attempt to shift left with overflow&quot;

Check 3: estimate_size.undefined-shift.1
         - Status: FAILURE
         - Description: &quot;shift distance too large&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
</details>
<h2 id="assertions-assumptions-and-harnesses"><a class="header" href="#assertions-assumptions-and-harnesses">Assertions, Assumptions, and Harnesses</a></h2>
<p>It seems a bit odd that our example function is tested against billions of possible inputs, when it really only seems to be designed to handle a few thousand.
Let's encode this fact about our function by asserting some reasonable upper bound on our input, after we've fixed our bug.
(New code available under <a href="https://github.com/model-checking/kani/tree/main/docs/src/tutorial/first-steps-v2/"><code>first-steps-v2</code></a>):</p>
<pre><code class="language-rust">fn estimate_size(x: u32) -&gt; u32 {
    assert!(x &lt; 4096);

    if x &lt; 256 {
        if x &lt; 128 {
            return 1;
        } else {
            return 3;
        }
    } else if x &lt; 1024 {
        if x &gt; 1022 {
            return 4;
        } else {
            return 5;
        }
    } else {
        if x &lt; 2048 {
            return 7;
        } else {
            return 9;
        }
    }
}
</code></pre>
<p>Now we've explicitly stated our previously implicit expectation: this function should never be called with inputs that are too big.
But if we attempt to verify this modified function, we run into a problem:</p>
<pre><code>[...]
RESULTS:
[...]
Check 3: estimate_size.assertion.1
         - Status: FAILURE
         - Description: &quot;assertion failed: x &lt; 4096&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<p>What we want is a <em>precondition</em> for <code>estimate_size</code>.
That is, something that should always be true every time we call the function.
By putting the assertion at the beginning, we ensure the function immediately fails if that expectation is not met.</p>
<p>But our proof harness will still call this function with any integer, even ones that just don't meet the function's preconditions.
That's... not a useful or interesting result.
We know that won't work already.
How do we go back to successfully verifying this function?</p>
<p>This is the purpose of writing a proof harness.
Much like property testing (which would also fail in this assertion), we need to set up our preconditions, call the function in question, then assert our postconditions.
Here's a revised example of the proof harness, one that now succeeds:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn verify_success() {
    let x: u32 = kani::any();
    kani::assume(x &lt; 4096);
    let y = estimate_size(x);
    assert!(y &lt; 10);
}
</code></pre>
<p>But now we must wonder if we've really fully tested our function.
What if we revise the function, but forget to update the assumption in our proof harness to cover the new range of inputs?</p>
<p>Fortunately, Kani is able to report a coverage metric for each proof harness.
Try running:</p>
<pre><code>cargo kani --visualize --harness verify_success
</code></pre>
<p>The beginning of the report includes coverage information.
Clicking through to the file will show fully-covered lines in green.
Lines not covered by our proof harness will show in red.</p>
<p>Try changing the assumption in the proof harness to <code>x &lt; 2048</code>.
Now the harness won't be testing all possible cases.
Rerun <code>cargo kani --visualize</code>.
Look at the report: you'll see we no longer have 100% coverage of the function.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw Kani find panics, assertion failures, and even some other failures like unsafe dereferencing of null pointers.</li>
<li>We saw Kani find failures that testing could not easily find.</li>
<li>We saw how to write a proof harness and use <code>kani::any()</code>.</li>
<li>We saw how to get a failing <strong>trace</strong> using <code>kani --visualize</code></li>
<li>We saw how proof harnesses are used to set up preconditions with <code>kani::assume()</code>.</li>
<li>We saw how to obtain <strong>coverage</strong> metrics and use them to ensure our proofs are covering as much as they should be.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="failures-that-kani-can-spot"><a class="header" href="#failures-that-kani-can-spot">Failures that Kani can spot</a></h1>
<p>In the <a href="./tutorial-first-steps.html">last section</a>, we saw Kani spot two major kinds of failures: assertions and panics.
If the proof harness allows some program execution that results in a panic, then Kani will report that as a failure.
In addition, we saw (very briefly) a couple of other kinds of failures: null pointer dereferences and overflows.
In this section, we're going to expand on these additional checks, to give you an idea of what other problems Kani will find.</p>
<h2 id="bounds-checking-and-pointers"><a class="header" href="#bounds-checking-and-pointers">Bounds checking and pointers</a></h2>
<p>Rust is safe by default, and so includes dynamic (run-time) bounds checking where needed.
Consider this Rust code (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/bounds_check.rs">here</a>):</p>
<pre><code class="language-rust">/// Wrap &quot;too-large&quot; indexes back into a valid range for the array
fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    if a.len() == 0 {
        return 0;
    }
    return a[i % a.len() + 1];
}
</code></pre>
<p>We can again write a simple property test against this code:</p>
<pre><code class="language-rust">    proptest! {
        #[test]
        fn doesnt_crash(i: usize, a: Vec&lt;u32&gt;) {
            get_wrapped(i, &amp;a);
        }
    }
</code></pre>
<p>This property test will immediately find a failing case, thanks to Rust's built-in bounds checking.</p>
<p>But what if we change this function to use unsafe Rust?</p>
<pre><code class="language-rust">return unsafe { *a.get_unchecked(i % a.len() + 1) };
</code></pre>
<p>Now the error becomes invisible to this test:</p>
<pre><code># cargo test
[...]
test bounds_check::tests::doesnt_crash ... ok
</code></pre>
<p>The property test still causes an out-of-bounds access, but this undefined behavior does not necessarily cause an immediate crash.
(This is part of why undefined behavior is so difficult to debug.)
Through the use of unsafe code, we removed the runtime check for an out of bounds access.
It just turned out that none of the randomly generated tests triggered behavior that actually crashed.
But if we write a Kani proof harness:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn bound_check() {
    let size: usize = kani::any();
    kani::assume(size &lt; 4096);
    let index: usize = kani::any();
    let array: Vec&lt;u32&gt; = vec![0; size];
    get_wrapped(index, &amp;array);
}
</code></pre>
<p>And run this proof with:</p>
<pre><code class="language-bash">cargo kani --harness bound_check
</code></pre>
<p>We still see a failure from Kani, even without Rust's runtime bounds checking.</p>
<blockquote>
<p>Also, notice there were many checks in the verification output.
(At time of writing, 351.)
This is a result of using the standard library <code>Vec</code> implementation, which means our harness actually used quite a bit of code, short as it looks.
Kani is inserting a lot more checks than appear as asserts in our code, so the output can be large.</p>
</blockquote>
<p>We get the following summary at the end:</p>
<pre><code>SUMMARY: 
 ** 1 of 351 failed
Failed Checks: dereference failure: pointer outside object bounds
 File: &quot;./src/bounds_check.rs&quot;, line 11, in bounds_check::get_wrapped

VERIFICATION:- FAILED
</code></pre>
<p>Notice that, for Kani, this has gone from a simple bounds-checking problem to a pointer-checking problem.
Kani will check operations on pointers to ensure they're not potentially invalid memory accesses.
Any unsafe code that manipulates pointers will, as we see here, raise failures if its behavior is actually a problem.</p>
<p>Consider trying a few more small exercises with this example:</p>
<ol>
<li>Exercise: Switch back to the normal/safe indexing operation and re-try Kani.
How does Kani's output change, compared to the unsafe operation?
(Try predicting the answer, then seeing if you got it right.)</li>
<li>Exercise: <a href="./tutorial-first-steps.html#getting-a-trace">Remember how to get a trace from Kani?</a> Find out what inputs it failed on.</li>
<li>Exercise: Fix the error, run Kani, and see a successful verification.</li>
<li>Exercise: Try switching back to the unsafe code (now with the error fixed) and re-run Kani. Does it still verify successfully?</li>
</ol>
<details>
<summary>Click to see explanation for exercise 1</summary>
<p>Having switched back to the safe indexing operation, Kani reports two failures:</p>
<pre><code>SUMMARY: 
 ** 2 of 350 failed
Failed Checks: index out of bounds: the length is less than or equal to the given index
 File: &quot;./src/bounds_check.rs&quot;, line 11, in bounds_check::get_wrapped
Failed Checks: dereference failure: pointer outside object bounds
 File: &quot;./src/bounds_check.rs&quot;, line 11, in bounds_check::get_wrapped

VERIFICATION:- FAILED
</code></pre>
<p>The first is Rust's runtime bounds checking for the safe indexing operation.
The second is Kani's check to ensure the pointer operation is actually safe.
This pattern (two checks for similar issues in safe Rust code) is common to see, and we'll see it again in the next section.</p>
<blockquote>
<p><strong>NOTE</strong>: While Kani will always be checking for both properties, <a href="https://github.com/model-checking/kani/issues/1349">in the future the output here may change</a>.
You might have noticed that the bad pointer dereference can't happen, since the bounds check would panic first.
In the future, Kani's output may report only the bounds checking failure in this example.</p>
</blockquote>
</details>
<details>
<summary>Click to see explanation for exercise 2</summary>
<p>Having run <code>cargo kani --harness bound_check --visualize</code> and clicked on one of the failures to see a trace, there are three things to immediately notice:</p>
<ol>
<li>This trace is huge. Because the standard library <code>Vec</code> is involved, there's a lot going on.</li>
<li>The top of the trace file contains some &quot;trace navigation tips&quot; that might be helpful in navigating the trace.</li>
<li>There's a lot of generated code and it's really hard to just read the trace itself.</li>
</ol>
<p>To navigate this trace to find the information you need, we again recommend searching for things you expect to be somewhere in the trace:</p>
<ol>
<li>Search the page for <code>kani::any</code> or <code>&lt;variable_of_interest&gt; =</code> such as <code>size =</code> or <code>let size</code>.
We can use this to find out what example values lead to a problem.
In this case, where we just have a couple of <code>kani::any</code> values in our proof harness, we can learn a lot just by seeing what these are.
In this trace we find (and the values you get may be different):</li>
</ol>
<pre><code>Step 36: Function bound_check, File src/bounds_check.rs, Line 37
let size: usize = kani::any();
size = 2464ul

Step 39: Function bound_check, File src/bounds_check.rs, Line 39
let index: usize = kani::any();
index = 2463ul
</code></pre>
<p>You may see different values here, as it depends on the solver's behavior.</p>
<ol start="2">
<li>Try searching for <code>failure:</code>. This will be near the end of the page.
You can now search upwards from a failure to see what values certain variables had.
Sometimes it can be helpful to change the source code to add intermediate variables, so their value is visible in the trace.
For instance, you might want to compute the index before indexing into the array.
That way you'd see in the trace exactly what value is being used.</li>
</ol>
<p>These two techniques should help you find both the nondeterministic inputs, and the values that were involved in the failing assertion.</p>
</details>
<h2 id="overflow-and-math-errors"><a class="header" href="#overflow-and-math-errors">Overflow and math errors</a></h2>
<p>Consider a different variant on the function above:</p>
<pre><code class="language-rust">fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    return a[i % a.len()];
}
</code></pre>
<p>We've corrected the out-of-bounds access, but now we've omitted the &quot;base case&quot;: what to return on an empty list.
Kani will spot this not as a bound error, but as a mathematical error: on an empty list the modulus operator (<code>%</code>) will cause a division by zero.</p>
<ol>
<li>Exercise: Try to run Kani on this version of <code>get_wrapped</code>, to see what this kind of failure looks like.</li>
</ol>
<p>Rust can also perform runtime safety checks for integer overflows, much like it does for bounds checks.
(<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow">Though Rust disables this by default in <code>--release</code> mode, it can be re-enabled.</a>)
Consider this code (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/overflow.rs">here</a>):</p>
<pre><code class="language-rust">fn simple_addition(a: u32, b: u32) -&gt; u32 {
    return a + b;
}
</code></pre>
<p>A trivial function, but if we write a property test for it, we immediately find inputs where it fails, thanks to Rust's dynamic checks.
Kani will find these failures as well.
Here's the output from Kani:</p>
<pre><code># cargo kani --harness add_overflow
[...]
SUMMARY: 
 ** 1 of 2 failed
Failed Checks: attempt to add with overflow
 File: &quot;./src/overflow.rs&quot;, line 7, in overflow::simple_addition

VERIFICATION:- FAILED
</code></pre>
<p>This issue can be fixed using Rust's alternative mathematical functions with explicit overflow behavior.
For instance, if the wrapping behavior is intended, you can write <code>a.wrapping_add(b)</code> instead of <code>a + b</code>.
Kani will then report no issues.</p>
<h3 id="exercise-classic-overflow-failure"><a class="header" href="#exercise-classic-overflow-failure">Exercise: Classic overflow failure</a></h3>
<p>A classic example of a subtle bug that persisted in many implementations for a very long time is &quot;finding the midpoint&quot; in quick sort.
This often naively looks like this (code available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/overflow_quicksort.rs">here</a>):</p>
<pre><code class="language-rust">fn find_midpoint(low: u32, high: u32) -&gt; u32 {
    return (low + high) / 2;
}
</code></pre>
<pre><code>cargo kani --harness midpoint_overflow
</code></pre>
<p>Kani immediately spots the bug in the above code.</p>
<ol>
<li>Exercise: Fix this function so it no longer overflows.
(Hint: depending on which approach you take, you may need to add the assumption that <code>high &gt; low</code> to your proof harness.
Don't add that right away, see what happens if you don't. Just keep it in mind.)</li>
<li>Exercise: Prove your new implementation actually finds the midpoint correctly by adding an assertion to the test harness.</li>
</ol>
<details>
<summary>Click to see solutions for these exercises</summary>
<p>A very common approach for resolving the overflow issue looks like this:</p>
<pre><code class="language-rust">return low + (high - low) / 2;
</code></pre>
<p>But if you naively try this (try it!), you'll find a new underflow error: <code>high - low</code> might result in a negative number, but has type <code>u32</code>.
Hence, the need to add the assumption we suggested above, to make that impossible.
(Adding an assumption, though, means there's a new way to &quot;use it wrong.&quot; Perhaps we'd like to avoid that! Can you avoid the assumption?)</p>
<p>After that, you might wonder how to &quot;prove your new implementation correct.&quot;
After all, what does &quot;correct&quot; even mean?
Often we're using a good approximation of correct, such as the equivalence of two implementations (often one much &quot;simpler&quot; than the other somehow).
Here's one possible assertion we could write in the proof harness:</p>
<pre><code class="language-rust">assert!(result as u64 == (a as u64 + b as u64) / 2);
</code></pre>
<p>You might have even come up with this approach to avoiding the overflow issue in the first place!
Having two different implementations, using different approaches, but proven to yield the same results, gives us greater confidence that we compute the correct result.</p>
</details>
<h2 id="failures-that-kani-cannot-spot"><a class="header" href="#failures-that-kani-cannot-spot">Failures that Kani cannot spot</a></h2>
<p>Check out <a href="./limitations.html">Limitations</a> for information on the checks that Kani does not perform.
Notably, Kani is not prioritizing all Rust-specific notions of undefined behavior.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw Kani spot out-of-bounds accesses.</li>
<li>We saw Kani spot actually-unsafe dereferencing of a raw pointer to invalid memory.</li>
<li>We got more experience reading the traces that Kani generates, to debug a failing proof harness.</li>
<li>We saw Kani spot a division by zero error and an overflowing addition.</li>
<li>As an exercise, we tried proving an assertion (finding the midpoint) that was not completely trivial.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-unwinding-and-bounds"><a class="header" href="#loops-unwinding-and-bounds">Loops, unwinding, and bounds</a></h1>
<p>Consider code like this (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/loops-unwinding/src/lib.rs">here</a>):</p>
<pre><code class="language-rust">fn initialize_prefix(length: usize, buffer: &amp;mut [u8]) {
    // Let's just ignore invalid calls
    if length &gt; buffer.len() {
        return;
    }

    for i in 0..=length {
        buffer[i] = 0;
    }
}
</code></pre>
<p>This code has an off-by-one error that only occurs on the last iteration of the loop (when called with an input that will trigger it).
We can try to find this bug with a proof harness like this:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
#[kani::unwind(1)] // deliberately too low
fn check_initialize_prefix() {
    const LIMIT: usize = 10;
    let mut buffer: [u8; LIMIT] = [1; LIMIT];

    let length = kani::any();
    kani::assume(length &lt;= LIMIT);

    initialize_prefix(length, &amp;mut buffer);
}
</code></pre>
<p>But we've just used a <a href="reference/attributes.html#kaniunwindnumber">new attribute</a> (<code>#[kani::unwind(1)]</code>) that requires some explanation.
When we run <code>cargo kani</code> on this code as we have written it, we see an odd verification failure:</p>
<pre><code>SUMMARY:
 ** 1 of 67 failed (66 undetermined)
Failed Checks: unwinding assertion loop 0

VERIFICATION:- FAILED
</code></pre>
<p>If we try removing this &quot;unwind&quot; annotation and re-running Kani, the result is worse: non-termination.
Kani simply doesn't produce a result.</p>
<p>The problem we're struggling with is the technique Kani uses to verify code.
We're not able to handle code with &quot;unbounded&quot; loops, and what &quot;bounded&quot; means can be quite subtle.
It has to have a constant number of iterations that's <em>&quot;obviously constant&quot;</em> enough for the verifier to actually figure this out.
In practice, very few loops are like this.</p>
<p>To verify programs like this with Kani as it exists today, we need to do two things:</p>
<ol>
<li>Set an upper bound on the size of the problem.
We've actually already done part of this: our proof harness above seems to be trying to set an upper <code>LIMIT</code> of 10.</li>
<li>Tell Kani about this limit if (or when) it's not able to figure it out on its own.
This is the purpose of the <code>kani::unwind</code> annotation.</li>
</ol>
<p>Bounding proofs like this means we may no longer be proving as much as we originally hoped.
Who's to say, if we prove everything works up to size 10, that there isn't a novel bug lurking, reachable only with problems of size 11+?
Perhaps!
But, let's get back to the issue at hand.</p>
<p>By putting <code>#[kani::unwind(1)]</code> on the proof harness, we've placed an upper bound of 1 loop iteration.
The &quot;unwinding assertion&quot; failure that Kani reports is because this bound is not high enough.
The code tries to execute more than 1 loop iteration.
(And, because the unwinding isn't high enough, many of the other properties Kani is verifying become &quot;undetermined&quot;: we don't really know if they're true or false, because we can't get far enough.)</p>
<p><strong>Exercise</strong>: Try increasing the bound. Where might you start? How high do you need to go to get rid of the &quot;unwinding assertion&quot; failure?</p>
<details>
<summary>Click to see explanation for the exercise</summary>
<p>Since the proof harness is trying to limit the array to size 10, an initial unwind value of 10 seems like the obvious place to start.
But that's not large enough for Kani, and we still see the &quot;unwinding assertion&quot; failure.</p>
<p>At size 11, the &quot;unwinding assertion&quot; goes away, and now we can see the actual failure we're trying to find too.
We'll explain why we see this behavior in a moment.</p>
</details>
<p>Once we have increased the unwinding limit high enough, we're left with these failures:</p>
<pre><code>SUMMARY:
 ** 1 of 68 failed
Failed Checks: index out of bounds: the length is less than or equal to the given index
 File: &quot;./src/lib.rs&quot;, line 12, in initialize_prefix

VERIFICATION:- FAILED
</code></pre>
<p><strong>Exercise</strong>: Fix the off-by-one error, and get the (bounded) proof to go through.</p>
<p>We now return to the question: why is 11 the unwinding bound?</p>
<p>Kani needs the unwinding bound to be &quot;one more than&quot; the number of loop iterations.
We previously had an off-by-one error that tried to do 11 iterations on an array of size 10.
So... the unwinding bound needed to be 11, then.</p>
<blockquote>
<p><strong>NOTE</strong>: Presently, there are some situations where &quot;number of iterations of a loop&quot; can be less obvious than it seems.
This can be easily triggered with use of <code>break</code> or <code>continue</code> within loops.
Often this manifests itself as needing &quot;two more&quot; or &quot;three more&quot; iterations in the unwind bound than seems like it would actually run.
In those situations, we might still need a bound like <code>kani::unwind(13)</code>, despite looking like a loop bounded to 10 iterations.</p>
</blockquote>
<p>The approach we've taken here is a general method for getting a bounded proof to go through:</p>
<ol>
<li>Put an actual upper bound on the problem itself.
Here that's accomplished via <code>LIMIT</code> in our proof harness.
We don't create a slice any bigger than that, and that's what we loop over.</li>
<li>Start at a reasonable guess for a <code>kani::unwind</code> bound, and increase until the unwinding assertion failure goes away.</li>
<li>Or, if that starts to take too long to verify, decrease your problem's bound, to accommodate the verifier's performance.</li>
</ol>
<h2 id="unwinding-value-specification"><a class="header" href="#unwinding-value-specification">Unwinding value specification</a></h2>
<p>The best approach to supplying Kani with unwind bounds is using the annotation <code>kani::unwind</code>, as we show above.</p>
<p>You might want to supply one via command line when experimenting, however.
In that case you can either use <code>--default-unwind x</code> to set an unwind bound for every proof harness that <strong>does not</strong> have an explicit bound.</p>
<p>Or you can <em>override</em> a harness's bound, but only when running a specific harness:</p>
<pre><code>cargo kani --harness check_initialize_prefix --unwind 11
</code></pre>
<p>Finally, you might be interested in defaulting the unwind bound to 1, to force termination (and force supplying a bound) on all your proof harnesses.
You can do this by putting this into your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[workspace.metadata.kani.flags]
default-unwind = 1
</code></pre>
<h2 id="bounded-proof"><a class="header" href="#bounded-proof">Bounded proof</a></h2>
<p>Before we finish, it's worth revisiting the implications of what we've done here.
Kani frequently needs to do &quot;bounded proof&quot;, which contrasts with unbounded or full verification.</p>
<p>We've written a proof harness that shows <code>initialize_prefix</code> has no errors on input slices of size 10, but no higher.
The particular size we choose is usually determined by balancing the level of assurance we want, versus runtime of Kani.
It's often not worth running proofs for large numbers of iterations, unless either very high assurance is necessary, or there's reason to suspect larger problems will contain novel failure modes.</p>
<p><strong>Exercise</strong>: Try increasing the problem size (both the unwind and the <code>LIMIT</code> constant). When does it start to take more than a few seconds?</p>
<details>
<summary>Click to see explanation for the exercise</summary>
<p>On your friendly neighborhood author's machine, a <code>LIMIT</code> of 100 takes about 3.8 seconds end-to-end.
This is a relatively simple bit of code, though, and it's not uncommon for some proofs to scale poorly even to 5 iterations.</p>
</details>
<p>One consequence of this, however, is that Kani often scales poorly to &quot;big string problems&quot; like parsing.
Often a parser will need to consume inputs larger than 10-20 characters to exhibit strange behaviors.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw Kani fail to terminate.</li>
<li>We saw how <code>#[kani::unwind(1)]</code> can help force Kani to terminate (with a verification failure).</li>
<li>We saw &quot;unwinding assertions&quot; verify that we've set the unwinding limit high enough.</li>
<li>We saw how to put a practical bound on problem size in our proof harness.</li>
<li>We saw how to pick an unwinding size large enough to successfully verify that bounded proof.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nondeterministic-variables"><a class="header" href="#nondeterministic-variables">Nondeterministic variables</a></h1>
<p>Kani is able to reason about programs and their execution paths by allowing users to create nondeterministic (also called symbolic) values using <code>kani::any()</code>.
Kani is a &quot;bit-precise&quot; model checker, which means that Kani considers all the possible bit-value combinations <em>that would be valid</em> if assigned to a variable's memory contents.
In other words, <code>kani::any()</code> should not produce values that are invalid for the type (which would lead to Rust undefined behavior).</p>
<p>Out of the box, Kani includes <code>kani::any()</code> implementations for most primitive and some <code>std</code> types.
In this tutorial, we will show how to use <code>kani::any()</code> to create symbolic values for other types. </p>
<h2 id="safe-nondeterministic-variables"><a class="header" href="#safe-nondeterministic-variables">Safe nondeterministic variables</a></h2>
<p>Let's say you're developing an inventory management tool, and you would like to start verifying properties about your API.
Here is a simple example (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/arbitrary-variables/src/inventory.rs">here</a>):</p>
<pre><code class="language-rust">use std::num::NonZeroU32;
use vector_map::VecMap;

pub type ProductId = u32;

pub struct Inventory {
    /// Every product in inventory must have a non-zero quantity
    pub inner: VecMap&lt;ProductId, NonZeroU32&gt;,
}

impl Inventory {
    pub fn update(&amp;mut self, id: ProductId, new_quantity: NonZeroU32) {
        self.inner.insert(id, new_quantity);
    }

    pub fn get(&amp;self, id: &amp;ProductId) -&gt; Option&lt;NonZeroU32&gt; {
        self.inner.get(id).cloned()
    }
}
</code></pre>
<p>Let's write a fairly simple proof harness, one that just ensures we successfully <code>get</code> the value we inserted with <code>update</code>:</p>
<pre><code class="language-rust">    #[kani::proof]
    #[kani::unwind(3)]
    pub fn safe_update() {
        // Empty to start
        let mut inventory = Inventory { inner: VecMap::new() };

        // Create non-deterministic variables for id and quantity.
        let id: ProductId = kani::any();
        let quantity: NonZeroU32 = kani::any();
        assert!(quantity.get() != 0, &quot;NonZeroU32 is internally a u32 but it should never be 0.&quot;);

        // Update the inventory and check the result.
        inventory.update(id, quantity);
        assert!(inventory.get(&amp;id).unwrap() == quantity);
    }
</code></pre>
<p>We use <code>kani::any()</code> twice here:</p>
<ol>
<li><code>id</code> has type <code>ProductId</code> which was actually just a <code>u32</code>, and so any value is fine.</li>
<li><code>quantity</code>, however, has type <code>NonZeroU32</code>.
In Rust, it would be undefined behavior to have a value of <code>0</code> for this type.</li>
</ol>
<p>We included an extra assertion that the value returned by <code>kani::any()</code> here was actually non-zero.
If we run this, you'll notice that verification succeeds.</p>
<pre><code class="language-bash">cargo kani --harness safe_update
</code></pre>
<p><code>kani::any()</code> is safe Rust, and so Kani only implements it for types where type invariants are enforced.
For <code>NonZeroU32</code>, this means we never return a <code>0</code> value.
The assertion we wrote in this harness was just an extra check we added to demonstrate this fact, not an essential part of the proof.</p>
<h2 id="custom-nondeterministic-types"><a class="header" href="#custom-nondeterministic-types">Custom nondeterministic types</a></h2>
<p>While <code>kani::any()</code> is the only method Kani provides to inject non-determinism into a proof harness, Kani only ships with implementations for a few <code>std</code> types where we can guarantee safety.
When you need nondeterministic variables of types that don't have a <code>kani::any()</code> implementation available, you have the following options:</p>
<ol>
<li>Implement the <code>kani::Arbitrary</code> trait for your type, so you and downstream crates can use <code>kani::any()</code> with your type.</li>
<li>Implement the <a href="https://docs.rs/bolero-generator/0.8.0/bolero_generator/trait.TypeGenerator.html"><code>bolero_generator::TypeGenerator</code> trait</a>.
This will enable you and downstream crates to use Kani via <a href="https://camshaft.github.io/bolero/">Bolero</a>.</li>
<li>Write a function that builds an object from non-deterministic variables.</li>
</ol>
<p>We recommend the first approach for most cases.
The first approach is simple and conventional. This option will also enable you to use it with parameterized types, such as <code>Option&lt;MyType&gt;</code> and arrays.
Kani includes a derive macro that allows you to automatically derive <code>kani::Arbitrary</code> for structures and enumerations as long as all its fields also implement the <code>kani::Arbitrary</code> trait.
One downside of this approach today is that the <code>kani</code> crate ships with Kani, but it's not yet available on <a href="https://crates.io">crates.io</a>.
So you need to annotate the Arbitrary implementation with a <code>#[cfg(kani)]</code> attribute.
For the derive macro, use <code>#[cfg_attr(kani, derive(kani::Arbitrary))]</code>.</p>
<p>The second approach is recommended for cases where you would also like to be able to apply fuzzing or property testing.
The benefits of doing so were described in <a href="https://model-checking.github.io/kani-verifier-blog/2022/10/27/using-kani-with-the-bolero-property-testing-framework.html">this blog post</a>.
Like <code>kani::Arbitrary</code>, this trait can also be used with a <code>derive</code> macro.
One thing to be aware of is that this type allow users to generate arbitrary values that include pointers.
In those cases, <strong>only the values pointed to are arbitrary</strong>, not the pointers themselves.</p>
<p>Finally, the last approach is recommended when you need to pass in parameters, like bounds on the size of the data structure.
(Which we'll discuss more in the next section.)
This approach is also necessary when you need to generate a nondeterministic variable of a type that you're importing from another crate, since Rust doesn't allow you to implement a trait defined in an external crate for a type that you don't own.</p>
<p>Either way, inside this function you would simply return an arbitrary value by generating arbitrary values for its components.
To generate a nondeterministic struct, you would just generate nondeterministic values for each of its fields.
For complex data structures like vectors or other containers, you can start with an empty one and add a (bounded) nondeterministic number of entries.</p>
<p>For example, for a simple enum you can just annotate it with the Arbitrary derive attribute:</p>
<pre><code class="language-rust">#[derive(Copy, Clone)]
#[cfg_attr(kani, derive(kani::Arbitrary))]
pub enum Rating {
    One,
    Two,
    Three,
}
</code></pre>
<p>But if the same enum is defined in an external crate, you can use a simple trick:</p>
<pre><code class="language-rust">    pub fn any_rating() -&gt; Rating {
        match kani::any() {
            0 =&gt; Rating::One,
            1 =&gt; Rating::Two,
            _ =&gt; Rating::Three,
        }
    }
</code></pre>
<p>All we're doing here is making use of a nondeterministic integer to decide which variant of <code>Rating</code> to return.</p>
<blockquote>
<p><strong>NOTE</strong>: If we thought of this code as generating a random value, this function looks heavily biased.
We'd overwhelmingly generate a <code>Three</code> because it's matching &quot;all other integers besides 1 and 2.&quot;
But Kani just see 3 meaningful possibilities, each of which is not treated any differently from each other.
The &quot;proportion&quot; of integers does not matter.</p>
</blockquote>
<h2 id="bounding-nondeterministic-variables"><a class="header" href="#bounding-nondeterministic-variables">Bounding nondeterministic variables</a></h2>
<p>You can use <code>kani::any()</code> for <code>[T; N]</code> (if implemented for <code>T</code>) because this array type has an exact and constant size.
But if you wanted a slice (<code>[T]</code>) up to size <code>N</code>, you can no longer use <code>kani::any()</code> for that.
Likewise, there is no implementation of <code>kani::any()</code> for more complex data structures like <code>Vec</code>.</p>
<p>The trouble with a nondeterministic vector is that you usually need to <em>bound</em> the size of the vector, for the reasons we investigated in the <a href="./tutorial-loop-unwinding.html">last chapter</a>.
The <code>kani::any()</code> function does not have any arguments, and so cannot be given an upper bound.</p>
<p>This does not mean you cannot have a nondeterministic vector.
It just means you have to construct one.
Our example proof harness above constructs a nondeterministic <code>Inventory</code> of size <code>1</code>, simply by starting with the empty <code>Inventory</code> and inserting a nondeterministic entry.</p>
<h3 id="exercise"><a class="header" href="#exercise">Exercise</a></h3>
<p>Try writing a function to generate a (bounded) nondeterministic inventory (from the first example:)</p>
<pre><code class="language-rust">fn any_inventory(bound: u32) -&gt; Inventory {
   // fill in here
}
</code></pre>
<p>One thing you'll quickly find is that the bounds must be very small.
Kani does not (yet!) scale well to nondeterministic-size data structures involving heap allocations.
A proof harness like <code>safe_update</code> above, but starting with <code>any_inventory(2)</code> will probably take a couple of minutes to prove.</p>
<p>A hint for this exercise: you might choose two different behaviors, &quot;size of exactly <code>bound</code>&quot; or &quot;size up to <code>bound</code>&quot;.
Try both!</p>
<p>A solution can be found in <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/arbitrary-variables/src/exercise_solution.rs"><code>exercise_solution.rs</code></a>.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw how <code>kani::any()</code> will return &quot;safe&quot; values for each of the types Kani implements it for.</li>
<li>We saw how to implement <code>kani::Arbitrary</code> or just write a function to create nondeterministic values for other types.</li>
<li>We noted that some types cannot implement <code>kani::any()</code> as they need a bound on their size.</li>
<li>We did an exercise to generate nondeterministic values of bounded size for <code>Inventory</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-verification-failures"><a class="header" href="#debugging-verification-failures">Debugging verification failures</a></h1>
<p>When the result of a certain check comes back as a <code>FAILURE</code>,
Kani offers different options to help debug:</p>
<ul>
<li><code>--concrete-playback</code>. This <em>experimental</em> feature generates a Rust unit test case that plays back a failing
proof harness using a concrete counterexample.</li>
<li><code>--visualize</code>. This feature generates an HTML text-based trace that
enumerates the execution steps leading to the check failure.</li>
</ul>
<h2 id="concrete-playback"><a class="header" href="#concrete-playback">Concrete playback</a></h2>
<p>When concrete playback is enabled, Kani will generate unit tests for assertions that failed during verification,
as well as cover statements that are reachable.</p>
<p>These tests can then be executed using Kani's playback subcommand.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>In order to enable this feature, run Kani with the <code>-Z concrete-playback --concrete-playback=[print|inplace]</code> flag.
After getting a verification failure, Kani will generate a Rust unit test case that plays back a failing
proof harness with a concrete counterexample.
The concrete playback modes mean the following:</p>
<ul>
<li><code>print</code>: Kani will just print the unit test to stdout.
You will then need to copy this unit test into the same module as your proof harness.
This is also helpful if you just want to quickly find out which values were assigned by <code>kani::any()</code> calls.</li>
<li><code>inplace</code>: Kani will automatically copy the unit test into your source code.
Before running this mode, you might find it helpful to have your existing code committed to <code>git</code>.
That way, you can easily remove the unit test with <code>git revert</code>.
Note that Kani will not copy the unit test into your source code if it detects
that the exact same test already exists. </li>
</ul>
<p>After the unit test is in your source code, you can run it with the <code>playback</code> subcommand.
To debug it, there are a couple of options:</p>
<ul>
<li>You can try <a href="https://github.com/model-checking/kani-vscode-extension">Kani's experimental extension</a>
provided for VSCode.</li>
<li>Otherwise, you can debug the unit test on the command line.</li>
</ul>
<p>To manually compile and run the test, you can use Kani's <code>playback</code> subcommand:</p>
<pre><code>cargo kani playback -Z concrete-playback -- ${unit_test_func_name}
</code></pre>
<p>The output from this command is similar to <code>cargo test</code>.
The output will have a line in the beginning like
<code>Running unittests {files} ({binary})</code>.</p>
<p>You can further debug the binary with tools like <code>rust-gdb</code> or <code>lldb</code>.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Running <code>kani -Z concrete-playback --concrete-playback=print</code> on the following source file:</p>
<pre><code class="language-rust">#[kani::proof]
fn proof_harness() {
    let a: u8 = kani::any();
    let b: u16 = kani::any();
    assert!(a / 2 * 2 == a &amp;&amp;
            b / 2 * 2 == b);
}
</code></pre>
<p>yields a concrete playback Rust unit test similar to the one below:</p>
<pre><code class="language-rust">#[test]
fn kani_concrete_playback_proof_harness_16220658101615121791() {
    let concrete_vals: Vec&lt;Vec&lt;u8&gt;&gt; = vec![
        // 133
        vec![133],
        // 35207
        vec![135, 137],
    ];
    kani::concrete_playback_run(concrete_vals, proof_harness);
}
</code></pre>
<p>Here, <code>133</code> and <code>35207</code> are the concrete values that, when substituted for <code>a</code> and <code>b</code>,
cause an assertion failure.
<code>vec![135, 137]</code> is the byte array representation of <code>35207</code>.</p>
<h3 id="request-for-comments"><a class="header" href="#request-for-comments">Request for comments</a></h3>
<p>This feature is experimental and is therefore subject to change.
If you have ideas for improving the user experience of this feature,
please add them to <a href="https://github.com/model-checking/kani/issues/1536">this GitHub issue</a>.
We are tracking the existing feature requests in
<a href="https://github.com/model-checking/kani/milestone/10">this GitHub milestone</a>.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<ul>
<li>This feature does not generate unit tests for failing non-panic checks (e.g., UB checks).
This is because checks would not trigger runtime errors during concrete playback.
Kani generates warning messages for this.</li>
<li>This feature does not support generating unit tests for multiple assertion failures within the same harness.
This limitation might be removed in the future.
Kani generates warning messages for this.</li>
<li>This feature requires that you use the same Kani version to generate the test and to playback. 
Any extra compilation option used during verification must be used during playback.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This section is the main reference for Kani.
It contains sections that informally describe its main features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>In Kani, attributes are used to mark functions as harnesses and control their execution.
This section explains the attributes available in Kani and how they affect the verification process.</p>
<p>At present, the available Kani attributes are the following:</p>
<ul>
<li><a href="reference/attributes.html#kaniproof"><code>#[kani::proof]</code></a></li>
<li><a href="reference/attributes.html#kanishould_panic"><code>#[kani::should_panic]</code></a></li>
<li><a href="reference/attributes.html#kaniunwindnumber"><code>#[kani::unwind(&lt;number&gt;)]</code></a></li>
<li><a href="reference/attributes.html#kanisolversolver"><code>#[kani::solver(&lt;solver&gt;)]</code></a></li>
<li><a href="reference/attributes.html#kanistuboriginal-replacement"><code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code></a></li>
</ul>
<h2 id="kaniproof"><a class="header" href="#kaniproof"><code>#[kani::proof]</code></a></h2>
<p><strong>The <code>#[kani::proof]</code> attribute specifies that a <a href="https://doc.rust-lang.org/reference/items/functions.html">function</a> is a proof harness.</strong></p>
<p>Proof harnesses are similar to test harnesses, especially property-based test harnesses,
and they may use functions from the Kani API (e.g., <code>kani::any()</code>).
A proof harness is the smallest verification unit in Kani.</p>
<p>When Kani is run, either through <code>kani</code> or <code>cargo kani</code>, it'll first collect all proof harnesses
(i.e., functions with the attribute <code>#[kani::proof]</code>) and then attempt to verify them.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>If we run Kani on this example:</p>
<pre><code class="language-rust">#[kani::proof]
fn my_harness() {
    assert!(1 + 1 == 2);
}
</code></pre>
<p>We should see a line in the output that says <code>Checking harness my_harness...</code> (assuming <code>my_harness</code> is the only harness in our code).
This will be followed by multiple messages that come from CBMC (the verification engine used by Kani) and the <a href="reference/../verification-results.html">verification results</a>.</p>
<p>Using any other Kani attribute without <code>#[kani::proof]</code> will result in compilation errors.</p>
<h3 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h3>
<p>The <code>#[kani::proof]</code> attribute can only be added to functions without parameters.</p>
<h2 id="kanishould_panic"><a class="header" href="#kanishould_panic"><code>#[kani::should_panic]</code></a></h2>
<p><strong>The <code>#[kani::should_panic]</code> attribute specifies that a proof harness is expected to panic.</strong></p>
<p>This attribute allows users to exercise <em>negative verification</em>.
It's analogous to how <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#testing-panics"><code>#[should_panic]</code></a> allows users to exercise <a href="https://en.wikipedia.org/wiki/Negative_testing">negative testing</a> for Rust unit tests.</p>
<p>This attribute <strong>only affects the overall verification result</strong>.
In particular, using the <code>#[kani::should_panic]</code> attribute will return one of the following results:</p>
<ul>
<li><code>VERIFICATION:- FAILED (encountered no panics, but at least one was expected)</code> if there were no failed checks.</li>
<li><code>VERIFICATION:- FAILED (encountered failures other than panics, which were unexpected)</code> if there were failed checks but not all them were related to panics.</li>
<li><code>VERIFICATION:- SUCCESSFUL (encountered one or more panics as expected)</code> otherwise.</li>
</ul>
<p>At the moment, to determine if a check is related to a panic, we check if its class is <code>assertion</code>.
The class is the second member in the property name, the triple that's printed after <code>Check X: </code>: <code>&lt;function&gt;.&lt;class&gt;.&lt;number&gt;</code>.
For example, the class in <code>Check 1: my_harness.assertion.1</code> is <code>assertion</code>, so this check is considered to be related to a panic.</p>
<blockquote>
<p><strong>NOTE</strong>: The <code>#[kani::should_panic]</code> is only recommended for writing
harnesses which complement existing harnesses that don't use the same
attribute. In order words, it's only recommended to write <em>negative harnesses</em>
after having written <em>positive</em> harnesses that successfully verify interesting
properties about the function under verification.</p>
</blockquote>
<h3 id="limitations-2"><a class="header" href="#limitations-2">Limitations</a></h3>
<p>The <code>#[kani::should_panic]</code> attribute verifies that there are one or more failed checks related to panics.
At the moment, it's not possible to pin it down to specific panics.
Therefore, <strong>it's possible that the panics detected with <code>#[kani::should_panic]</code> aren't the ones that were originally expected</strong> after a change in the code under verification.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p>Let's assume we're using the <code>Device</code> from this example:</p>
<pre><code class="language-rust">struct Device {
    is_init: bool,
}

impl Device {
    fn new() -&gt; Self {
        Device { is_init: false }
    }

    fn init(&amp;mut self) {
        assert!(!self.is_init);
        self.is_init = true;
    }
}
</code></pre>
<p>We may want to verify that calling <code>device.init()</code> more than once should result in a panic.
We can do so with the following harness:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::should_panic]
fn cannot_init_device_twice() {
    let mut device = Device::new();
    device.init();
    device.init();
}
</code></pre>
<p>Running Kani on it will produce the result <code>VERIFICATION:- SUCCESSFUL (encountered one or more panics as expected)</code></p>
<h2 id="kaniunwindnumber"><a class="header" href="#kaniunwindnumber"><code>#[kani::unwind(&lt;number&gt;)]</code></a></h2>
<p><strong>The <code>#[kani::unwind(&lt;number&gt;)]</code> attribute specifies that all loops must be unwound up to <code>&lt;number&gt;</code> times.</strong></p>
<p>By default, Kani attempts to unwind all loops automatically.
However, this unwinding process doesn't always terminate.
The <code>#[kani::unwind(&lt;number&gt;)]</code> attribute will:</p>
<ol>
<li>Disable automatic unwinding.</li>
<li>Unwind all loops up to <code>&lt;number&gt;</code> times.</li>
</ol>
<p>After the unwinding stage, Kani will attempt to verify the harness.
If the <code>#[kani::unwind(&lt;number&gt;)]</code> attribute was specified, there's a chance that one or more loops weren't unwound enough times.
In that case, there will be at least one failed unwinding assertion (there's one unwinding assertion for each loop), causing verification to fail.</p>
<p>Check the <a href="reference/../tutorial-loop-unwinding.html"><em>Loops, unwinding and bounds</em> section</a> for more information about unwinding.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<p>Let's assume we've written this code which contains a loop:</p>
<pre><code class="language-rust">fn my_sum(vec: &amp;Vec&lt;u32&gt;) -&gt; u32 {
    let mut sum = 0;
    for elem in vec {
        sum += elem;
    }
    sum
}

#[kani::proof]
fn my_harness() {
    let vec = vec![1, 2, 3];
    let sum = my_sum(&amp;vec);
    assert!(sum == 6);
}
</code></pre>
<p>Running this example on Kani will produce a successful verification result.
In this case, Kani automatically finds the required unwinding value (i.e., the number of times it needs to unwind all loops).
This means that the <code>#[kani::unwind(&lt;number&gt;)]</code> attribute isn't needed, as we'll see soon.
In general, the required unwinding value is equal to the maximum number of iterations for all loops, plus one.
The required unwinding value in this example is 4: the 3 iterations in the <code>for elem in vec</code> loop, plus 1.</p>
<p>Let's see what happens if we force a lower unwinding value with <code>#[kani::unwind(3)]</code>:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(3)]
fn my_harness() {
    let vec = vec![1, 2, 3];
    let sum = my_sum(&amp;vec);
    assert!(sum == 6);
}
</code></pre>
<p>As we mentioned, trying to verify this harness causes an unwinding failure:</p>
<pre><code>SUMMARY:
 ** 1 of 187 failed (186 undetermined)
Failed Checks: unwinding assertion loop 0
 File: &quot;/home/ubuntu/devices/src/main.rs&quot;, line 32, in my_sum

VERIFICATION:- FAILED
[Kani] info: Verification output shows one or more unwinding failures.
[Kani] tip: Consider increasing the unwinding value or disabling `--unwinding-assertions`.
</code></pre>
<p>Kani cannot verify the harness because there is at least one unwinding assertion failure.
But, if we use <code>#[kani::unwind(4)]</code>, which is the right unwinding value we computed earlier:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(4)]
fn my_harness() {
    let vec = vec![1, 2, 3];
    let sum = my_sum(&amp;vec);
    assert!(sum == 6);
}
</code></pre>
<p>We'll get a successful result again:</p>
<pre><code>SUMMARY:
 ** 0 of 186 failed

VERIFICATION:- SUCCESSFUL
</code></pre>
<h2 id="kanisolversolver"><a class="header" href="#kanisolversolver"><code>#[kani::solver(&lt;solver&gt;)]</code></a></h2>
<p><strong>Changes the solver to be used by Kani's verification engine (CBMC).</strong></p>
<p>This may change the verification time required to verify a harness.</p>
<p>At present, <code>&lt;solver&gt;</code> can be one of:</p>
<ul>
<li><code>minisat</code>: <a href="http://minisat.se/">MiniSat</a>.</li>
<li><code>cadical</code> (default): <a href="https://github.com/arminbiere/cadical">CaDiCaL</a>.</li>
<li><code>kissat</code>: <a href="https://github.com/arminbiere/kissat">kissat</a>.</li>
<li><code>bin=&quot;&lt;SAT_SOLVER_BINARY&gt;&quot;</code>: A custom solver binary, <code>&quot;&lt;SAT_SOLVER_BINARY&gt;&quot;</code>, that must be in path.</li>
</ul>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<p>Kani will use the CaDiCaL solver in the following example:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::solver(cadical)]
fn check() {
    let mut a = [2, 3, 1];
    a.sort();
    assert_eq!(a[0], 1);
    assert_eq!(a[1], 2);
    assert_eq!(a[2], 3);
}
</code></pre>
<p>Changing the solver may result in different verification times depending on the harness.</p>
<p>Note that the default solver may vary depending on Kani's version.
We highly recommend users to annotate their harnesses if the choice of solver
has a major impact on performance, even if the solver used is the current
default one.</p>
<h2 id="kanistuboriginal-replacement"><a class="header" href="#kanistuboriginal-replacement"><code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code></a></h2>
<p><strong>Replaces the function/method with name <original> with the function/method with name <replacement> during compilation</strong></p>
<p>Check the <a href="reference/../reference/stubbing.html"><em>Stubbing</em> section</a> for more information about stubbing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stubbing"><a class="header" href="#stubbing">Stubbing</a></h1>
<p>Stubbing (or mocking) is an unstable feature which allows users to specify that certain items should be replaced with stubs (mocks) of those items during verification.
At present, the only items where stubbing can be applied are functions and methods (see <a href="reference/stubbing.html#limitations">limitations</a> for more details).</p>
<h2 id="when-to-consider-stubbing"><a class="header" href="#when-to-consider-stubbing">When to consider stubbing</a></h2>
<p>In general, we have identified three reasons where users may consider stubbing:</p>
<ul>
<li><strong>Unsupported features:</strong> The code under verification contains features that Kani does not support, such as inline assembly.</li>
<li><strong>Bad performance:</strong> The code under verification contains features that Kani supports, but it leads to bad verification performance (for example, deserialization code).</li>
<li><strong>Compositional reasoning:</strong> The code under verification contains code that has been verified separately.
Stubbing the code that has already been verified with a less complex version that mimics its behavior can result in reduced verification workloads.</li>
</ul>
<p>In most cases, stubbing enables users to verify code that otherwise would be impractical to verify.
Although definitions for <em>mocking</em> (normally used in testing) and <em>stubbing</em> may slightly differ depending on who you ask, we often use both terms interchangeably.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The stubbing feature can be enabled by using the <code>--enable-stubbing</code> option when calling Kani.
Since it's an unstable feature, it requires passing the <code>--enable-unstable</code> option in addition to <code>--enable-stubbing</code>.</p>
<p>At present, the only component of the stubbing feature is <a href="reference/stubbing.html#the-kanistub-attribute">the <code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code> attribute</a>,
which allows you to specify the pair of functions/methods that must be stubbed in a harness.</p>
<!--
the other components expected to be here in the future are: the `stub_set(...)!` macro, off-the-shelf verification-friendly implementations, and automated
stubbing suggestions)
-->
<h2 id="the-kanistub-attribute"><a class="header" href="#the-kanistub-attribute">The <code>#[kani::stub(...)]</code> attribute</a></h2>
<p>The stub attribute <code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code>  is the main tool of the stubbing feature.</p>
<p>It indicates to Kani that the function/method with name <code>&lt;original&gt;</code> should be replaced with the function/method with name <code>&lt;replacement&gt;</code> during the compilation step.
The names of these functions/methods are <strong>resolved using Rust's standard name resolution rules</strong>.
This includes support for imports like <code>use foo::bar as baz</code>, as well as imports of multiple versions of the same crate.</p>
<p><strong>This attribute must be specified on a per-harness basis</strong>. This provides a high degree of flexibility for users, since they are given the option to stub the same item with different replacements (or not use stubbing at all) depending on the proof harness. In addition, <strong>the attribute can be specified multiple times per harness</strong>, so that multiple (non-conflicting) stub pairings are supported.</p>
<h3 id="an-example-stubbing-random"><a class="header" href="#an-example-stubbing-random">An example: stubbing <code>random</code></a></h3>
<p>Let's see a simple example where we use the <a href="https://docs.rs/rand/latest/rand/fn.random.html"><code>rand::random</code></a> function
to generate an encryption key.</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn encrypt_then_decrypt_is_identity() {
    let data: u32 = kani::any();
    let encryption_key: u32 = rand::random();
    let encrypted_data = data ^ encryption_key;
    let decrypted_data = encrypted_data ^ encryption_key;
    assert_eq!(data, decrypted_data);
}

</code></pre>
<p>At present, Kani fails to verify this example due to <a href="https://github.com/model-checking/kani/issues/1781">issue #1781</a>.</p>
<p>However, we can work around this limitation thanks to the stubbing feature:</p>
<pre><code class="language-rust">#[cfg(kani)]
fn mock_random&lt;T: kani::Arbitrary&gt;() -&gt; T {
    kani::any()
}

#[cfg(kani)]
#[kani::proof]
#[kani::stub(rand::random, mock_random)]
fn encrypt_then_decrypt_is_identity() {
    let data: u32 = kani::any();
    let encryption_key: u32 = rand::random();
    let encrypted_data = data ^ encryption_key;
    let decrypted_data = encrypted_data ^ encryption_key;
    assert_eq!(data, decrypted_data);
}
</code></pre>
<p>Here, the <code>#[kani::stub(rand::random, mock_random)]</code> attribute indicates to Kani that it should replace <code>rand::random</code> with the stub <code>mock_random</code>.
Note that this is a fair assumption to do: <code>rand::random</code> is expected to return any <code>u32</code> value, just like <code>kani::any</code>.</p>
<p>Now, let's run it through Kani:</p>
<pre><code class="language-bash">cargo kani --enable-unstable --enable-stubbing --harness encrypt_then_decrypt_is_identity
</code></pre>
<p>The verification result is composed of a single check: the assertion corresponding to <code>assert_eq!(data, decrypted_data)</code>.</p>
<pre><code>RESULTS:
Check 1: encrypt_then_decrypt_is_identity.assertion.1
         - Status: SUCCESS
         - Description: &quot;assertion failed: data == decrypted_data&quot;
         - Location: src/main.rs:18:5 in function encrypt_then_decrypt_is_identity


SUMMARY:
 ** 0 of 1 failed

VERIFICATION:- SUCCESSFUL
</code></pre>
<p>Kani shows that the assertion is successful, avoiding any issues that appear if we attempt to verify the code without stubbing.</p>
<h2 id="limitations-3"><a class="header" href="#limitations-3">Limitations</a></h2>
<p>In the following, we describe all the limitations of the stubbing feature.</p>
<h3 id="usage-restrictions"><a class="header" href="#usage-restrictions">Usage restrictions</a></h3>
<p>The usage of stubbing is limited to the verification of a single harness.
Therefore, users are <strong>required to pass the <code>--harness</code> option</strong> when using the stubbing feature.</p>
<p>In addition, this feature <strong>isn't compatible with <a href="reference/../debugging-verification-failures.html#concrete-playback">concrete playback</a></strong>.</p>
<h3 id="support"><a class="header" href="#support">Support</a></h3>
<p>Support for stubbing is currently <strong>limited to functions and methods</strong>. All other items aren't supported.</p>
<p>The following are examples of items that could be good candidates for stubbing, but aren't supported:</p>
<ul>
<li>Types</li>
<li>Macros</li>
<li>Traits</li>
<li>Intrinsics</li>
</ul>
<p>We acknowledge that support for method stubbing isn't as ergonomic as it could be.
A common problem when attempting to define method stubs is that we don't have access to the private fields of an object (i.e., the fields in <code>self</code>).
One workaround is to use the unsafe function <code>std::mem::transmute</code>, as in this example:</p>
<pre><code class="language-rust">struct Foo {
    x: u32,
}

impl Foo {
    pub fn m(&amp;self) -&gt; u32 {
        0
    }
}

struct MockFoo {
    pub x: u32,
}

fn mock_m(foo: &amp;Foo) -&gt; u32 {
    let mock: &amp;MockFoo = unsafe { std::mem::transmute(foo) };
    return mock.x;
}

#[cfg(kani)]
#[kani::proof]
#[kani::stub(Foo::m, mock_m)]
fn my_harness() { ... }
</code></pre>
<p>However, this isn't recommended since it's unsafe and error-prone.
In general, we don't recommend stubbing for private functions/methods.
Doing so can lead to brittle proofs: private functions/methods are subject to change or removal even in version minor upgrades (they aren't part of the APIs).
Therefore, proofs that rely on stubbing for private functions/methods might incur a high maintenance burden.</p>
<h2 id="error-conditions"><a class="header" href="#error-conditions">Error conditions</a></h2>
<p>Given a set of <code>original</code>-<code>replacement</code> pairs, Kani will exit with an error if:</p>
<ol>
<li>a specified <code>original</code> function does not exist;</li>
<li>a specified <code>replacement</code> stub does not exist;</li>
<li>the user specifies conflicting stubs for the same harness (e.g., if the same <code>original</code> function is mapped to multiple <code>replacement</code> functions); or</li>
<li>the signature of the <code>replacement</code> stub is not compatible with the signature of the <code>original</code> function/method (see next section).</li>
</ol>
<h3 id="stub-compatibility-and-validation"><a class="header" href="#stub-compatibility-and-validation">Stub compatibility and validation</a></h3>
<p>We consider a stub and a function/method to be compatible if all the following conditions are met:</p>
<ul>
<li>They have the same number of parameters.</li>
<li>They have the same return type.</li>
<li>Each parameter in the stub has the same type as the corresponding parameter in the original function/method.</li>
<li>The stub must have the same number of generic parameters as the original function/method.
However, a generic parameter in the stub is allowed to have a different name than the corresponding parameter in the original function/method.
For example, the stub <code>bar&lt;A, B&gt;(x: A, y: B) -&gt; B</code> is considered to have a type compatible with the function <code>foo&lt;S, T&gt;(x: S, y: T) -&gt; T</code>.</li>
<li>The bounds for each type parameter don't need to match; however, all calls to the original function must also satisfy the bounds of the stub.</li>
</ul>
<p>The final point is the most subtle.
We don't require that a type parameter in the signature of the stub implements the same traits as the corresponding type parameter in the signature of the original function/method.
However, Kani will reject a stub if a trait mismatch leads to a situation where a statically dispatched call to a trait method cannot be resolved during monomorphization.
For example, this restriction rules out the following harness:</p>
<pre><code class="language-rust">fn foo&lt;T&gt;(_x: T) -&gt; bool {
    false
}

trait DoIt {
    fn do_it(&amp;self) -&gt; bool;
}

fn bar&lt;T: DoIt&gt;(x: T) -&gt; bool {
    x.do_it()
}

#[kani::proof]
#[kani::stub(foo, bar)]
fn harness() {
    assert!(foo(&quot;hello&quot;));
}
</code></pre>
<p>The call to the trait method <code>DoIt::do_it</code> is unresolvable in the stub <code>bar</code> when the type parameter <code>T</code> is instantiated with the type <code>&amp;str</code>.
On the other hand, this approach provides some flexibility, such as allowing our earlier example of mocking <code>rand::random</code>:
both <code>rand::random</code> and <code>my_random</code> have type <code>() -&gt; T</code>, but in the first case <code>T</code> is restricted such that the type <code>Standard</code> implements <code>Distribution&lt;T&gt;</code>,
whereas in the latter case <code>T</code> has to implement <code>kani::Arbitrary</code>.
This trait mismatch is allowed because at this call site <code>T</code> is instantiated with <code>u32</code>, which implements <code>kani::Arbitrary</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application"><a class="header" href="#application">Application</a></h1>
<p>You may be interested in applying Kani if you're in this situation:</p>
<ol>
<li>You're working on a moderately important project in Rust.</li>
<li>You've already invested heavily in testing to ensure correctness.</li>
<li>You want to invest further, to gain a much higher degree of assurance.</li>
</ol>
<blockquote>
<p>If you haven't already, we also recommend techniques like property testing and fuzzing (e.g. with <a href="https://github.com/camshaft/bolero/"><code>bolero</code></a>).
These yield good results, are very cheap to apply, and are often easy to adopt and debug. </p>
</blockquote>
<p>In this section, we explain <a href="./tool-comparison.html">how Kani compares with other tools</a>
and suggest <a href="./tutorial-real-code.html">where to start applying Kani in real code</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison-with-other-tools"><a class="header" href="#comparison-with-other-tools">Comparison with other tools</a></h1>
<p><strong>Fuzzing</strong> (for example, with <a href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a>) is a unguided approach to random testing.
A fuzzer generally provides an input of random bytes, and then examines fairly generic properties (such as &quot;doesn't crash&quot; or &quot;commit undefined behavior&quot;) about the resulting program.</p>
<p>Fuzzers generally get their power through a kind of evolutionary algorithm that rewards new mutant inputs that &quot;discover&quot; new branches of the program under test.
Fuzzers are excellent for testing security boundaries, precisely because they make no validity assumptions (hence, they are &quot;unguided&quot;) when generating the input.</p>
<p><strong>Property testing</strong> (for example, with <a href="https://github.com/AltSysrq/proptest">Proptest</a>) is a guided approach to random testing.
&quot;Guided&quot; in the sense that the test generally provides a strategy for generating random values that constrains their range.
The purpose of this strategy is to either focus on interesting values, or avoid failing assertions that only hold for a constrained set of inputs.
Tests in this style do actually state properties: <em>For all inputs (of some constrained kind), this condition should hold</em>.</p>
<p>Property testing is often quite effective, but the engine can't fully prove the property: It can only sample randomly a few of those values to test (though property testing libraries frequently give interesting &quot;edge cases&quot; a higher probability, making them more effective at bug-finding).</p>
<p><strong>Model checking</strong> is similar to these techniques in how you use them, but it's non-random and exhaustive (though often only up to some bound on input or problem size).
Thus, properties checked with a model checker are effectively proofs.
Instead of naively trying all possible <em>concrete</em> inputs (which could be infeasible and blow up exponentially), model checkers like Kani will cleverly encode program traces as <em>symbolic</em> &quot;<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a>/<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>&quot; problems, and hand them off to SAT/SMT solvers.
SAT/SMT solving is an <a href="https://en.wikipedia.org/wiki/NP-completeness">NP-complete</a> problem, but many practical programs can be model-checked within milliseconds to seconds (with notable exceptions: you can easily try to reverse a cryptographic hash with a model checker, but good luck getting it to terminate!)</p>
<p>Model checking allows you to prove non-trivial properties about programs, and check those proofs in roughly the same amount of time as a traditional test suite would take to run.
The downside is many types of properties can quickly become &quot;too large&quot; to practically model-check, and so writing &quot;proof harnesses&quot; (very similar to property tests and fuzzer harnesses) requires some skill to understand why the solver is not terminating and fix the structure of the problem you're giving it so that it does.
This process basically boils down to &quot;debugging&quot; the proof.</p>
<h2 id="looking-for-concurrency"><a class="header" href="#looking-for-concurrency">Looking for concurrency?</a></h2>
<p>At present, Kani <a href="./rust-feature-support.html">does not support verifying concurrent code</a>.
Two tools of immediate interest are <a href="https://github.com/tokio-rs/loom">Loom</a> and <a href="https://github.com/awslabs/shuttle">Shuttle</a>.
Loom attempts to check all possible interleavings, while Shuttle chooses interleavings randomly.
The former is sound (like Kani), but the latter is more scalable to large problem spaces (like property testing).</p>
<h2 id="other-tools"><a class="header" href="#other-tools">Other tools</a></h2>
<p>The Rust Formal Methods Interest Group maintains <a href="https://rust-formal-methods.github.io/tools.html">a list of interesting Rust verification tools</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-to-start-on-real-code"><a class="header" href="#where-to-start-on-real-code">Where to start on real code</a></h1>
<p>It can be daunting to find the right place to start writing proofs for a real-world project.
This section will try to help you get over that hurdle.</p>
<p>In general, you're trying to do three things:</p>
<ol>
<li>Find a place where it'd be valuable to have a proof.</li>
<li>Find a place where it won't be too difficult to prove something, just to start.</li>
<li>Figure out what a feasible longer-term goal might be.</li>
</ol>
<p><strong>By far, the best strategy is to follow your testing.</strong>
Places where proof will be valuable are often places where you've written a lot of tests, because they're valuable there for the same reasons.
Likewise, code structure changes to make functions more unit-testable will also make functions more amenable to proof.
Often, by examining existing unit tests (and especially property tests), you can easily find a relatively self-contained function that's a good place to start.</p>
<h2 id="where-is-proof-valuable"><a class="header" href="#where-is-proof-valuable">Where is proof valuable?</a></h2>
<ol>
<li>
<p>Where complicated things happen with untrusted user input.
These are often the critical &quot;entry points&quot; into the code.
These are also places where you probably want to try other techniques (e.g., fuzz testing).</p>
</li>
<li>
<p>Where <code>unsafe</code> is used extensively.
These are often places where you'll already have concentrated a lot of tests.</p>
</li>
<li>
<p>Where you have a complicated implementation that accomplishes a much simpler abstract problem.
Ideal places for property testing, if you haven't tried that already.
But the usual style of property tests you often write here (generate large random lists of operations, then compare between concrete and abstract model) won't be practical to directly port to model checking.</p>
</li>
<li>
<p>Where normal testing &quot;smells&quot; intractable.</p>
</li>
</ol>
<h2 id="where-is-it-easier-to-start"><a class="header" href="#where-is-it-easier-to-start">Where is it easier to start?</a></h2>
<ol>
<li>
<p>Find crates or files with smaller lists of dependencies.
Dependencies can sometimes blow up the tractability of proofs.
This can usually be handled, but requires a lot more investment to make it happen, and so isn't a good place to start.</p>
</li>
<li>
<p>Don't forget to consider starting with your dependencies.
Sometimes the best place to start won't be your code, but the code that you depend on.
If it's used by more projects that just yours, it will be valuable to more people, too!</p>
</li>
<li>
<p>Find well-tested code.
When you make changes to improve the unit-testability of code, that also makes it more amenable to proof, too.</p>
</li>
</ol>
<p>Here are some things to avoid, when starting out:</p>
<ol>
<li>
<p>Lots of loops, or at least nested loops.
As we saw in the <a href="./tutorial-loop-unwinding.html">tutorial</a>, right now we often need to put upper bounds on loops to make more limited claims.</p>
</li>
<li>
<p>Inductive data structures.
These are data structures with unbounded size (e.g., linked lists or trees.)
These can be hard to model since you need to set bounds on their size, similar to what happens with loops.</p>
</li>
<li>
<p>Input/Output code.
Kani doesn't model I/O, so if your code depends on behavior like reading/writing to a file, you won't be able to prove anything.
This is one obvious area where testability helps provability: often we separate I/O and &quot;pure&quot; computation into different functions, so we can unit-test the latter.</p>
</li>
<li>
<p>Deeper call graphs.
Functions that call a lot of other functions can require more investment to make tractable.
They may not be a good starting point.</p>
</li>
<li>
<p>Significant global state.
Rust tends to discourage this, but it still exists in some forms.</p>
</li>
</ol>
<h2 id="your-first-proof"><a class="header" href="#your-first-proof">Your first proof</a></h2>
<p>A first proof will likely start in the following form:</p>
<ol>
<li>Nondeterministically initialize variables that will correspond to function inputs, with as few constraints as possible.</li>
<li>Call the function in question with these inputs.</li>
<li>Don't (yet) assert any post-conditions.</li>
</ol>
<p>Running Kani on this simple starting point will help figure out:</p>
<ol>
<li>What unexpected constraints might be needed on your inputs (using <code>kani::assume</code>) to avoid &quot;expected&quot; failures.</li>
<li>Whether you're over-constrained. Check the coverage report using <code>--visualize</code>. Ideally you'd see 100% coverage, and if not, it's usually because you've assumed too much (thus over-constraining the inputs).</li>
<li>Whether Kani will support all the Rust features involved.</li>
<li>Whether you've started with a tractable problem.
(Remember to try setting <code>#[kani::unwind(1)]</code> to force early termination and work up from there.)</li>
</ol>
<p>Once you've got something working, the next step is to prove more interesting properties than just what Kani covers by default.
You accomplish this by adding new assertions (not just in your harness, but also to the code being run).
Even if a proof harness has no post-conditions being asserted directly, the assertions encountered along the way can be meaningful proof results by themselves.</p>
<h2 id="examples-of-the-use-of-kani"><a class="header" href="#examples-of-the-use-of-kani">Examples of the use of Kani</a></h2>
<p>On the <a href="https://model-checking.github.io/kani-verifier-blog/">Kani blog</a>, we've documented worked examples of applying Kani:</p>
<ol>
<li><a href="https://model-checking.github.io/kani-verifier-blog/2022/05/04/announcing-the-kani-rust-verifier-project.html">The <code>Rectangle</code> example of the Rust Book</a></li>
<li><a href="https://model-checking.github.io/kani-verifier-blog/2022/06/01/using-the-kani-rust-verifier-on-a-rust-standard-library-cve.html">A Rust standard library CVE</a></li>
<li><a href="https://model-checking.github.io/kani-verifier-blog/2022/07/13/using-the-kani-rust-verifier-on-a-firecracker-example.html">Verifying a part of Firecracker</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-documentation"><a class="header" href="#developer-documentation">Developer documentation</a></h1>
<p>Kani is an open source project open to external contributions.</p>
<p>The easiest way to contribute is to <a href="https://github.com/model-checking/kani/issues/new/choose">report any
issue</a> you encounter
while using the tool. If you want to contribute to its development,
we recommend looking into <a href="https://github.com/model-checking/kani/contribute">these issues</a>.</p>
<p>In this chapter, we provide documentation that might be helpful for Kani
developers (including external contributors):</p>
<ol>
<li><a href="./conventions.html">Coding conventions</a>.</li>
<li><a href="./cheat-sheets.html">Useful command-line instructions for Kani/CBMC/Git</a>.</li>
<li><a href="./cbmc-hacks.html">Development setup recommendations for working with <code>cbmc</code></a>.</li>
<li><a href="./rustc-hacks.html">Development setup recommendations for working with <code>rustc</code></a>.</li>
<li><a href="./testing.html">Guide for testing in Kani</a>.</li>
<li><a href="./stable-mir.html">Transition to StableMIR</a>.</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>: The developer documentation is intended for Kani developers and not
users. At present, the project is under heavy development and some items
discussed in this documentation may stop working without notice (e.g., commands
or configurations). Therefore, we recommend users to not rely on them.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coding-conventions"><a class="header" href="#coding-conventions">Coding conventions</a></h1>
<h2 id="formatting"><a class="header" href="#formatting">Formatting</a></h2>
<p>We automate most of our formatting preferences. Our CI will run format checkers for PRs and pushes.
These checks are required for merging any PR.</p>
<p>For Rust, we use <a href="https://github.com/rust-lang/rustfmt">rustfmt</a>
which is configured via the <a href="https://github.com/model-checking/kani/blob/main/rustfmt.toml">rustfmt.toml</a> file.
We are also in the process of enabling <code>clippy</code>.
Because of that, we still have a couple of lints disabled (see <a href="https://github.com/model-checking/kani/blob/main/.cargo/config.toml">.cargo/config</a> for the updated list).</p>
<p>We also have a bit of C and Python code in our repository.
For C we use <code>clang-format</code> and for Python scripts we use <code>autopep8</code>.
See <a href="https://githubcom/model-checking/kani/blob/main/.clang-format">.clang-format</a>
and <a href="https://github.com/model-checking/kani/blob/main/scripts/pyproject.toml">pyproject.toml</a>
for their configuration.</p>
<h3 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h3>
<p>We recognize that in some cases, the formatting and lints automation may not be applicable to a specific code.
In those cases, we usually prefer explicitly allowing exceptions by locally disabling the check.
E.g., use <code>#[allow]</code> annotation instead of disabling a link on a crate or project level.</p>
<h3 id="copyright-notice"><a class="header" href="#copyright-notice">Copyright notice</a></h3>
<p>All source code files begin with a copyright and license notice. If this is a new file, please add the following notice:</p>
<pre><code class="language-rust">// Copyright Kani Contributors
// SPDX-License-Identifier: Apache-2.0 OR MIT
</code></pre>
<p>When modifying a file from another project, please keep their headers as is and append the following notice after them:</p>
<pre><code class="language-rust">// ... existing licensing headers ...

// Modifications Copyright Kani Contributors
// See GitHub history for details.
</code></pre>
<p>Note: The comment escape characters will depend on the type of file you are working with. E.g.: For rust start the 
header with <code>//</code>, but for python start with <code>#</code>.</p>
<p>We also have automated checks for the copyright notice.
There are a few file types where this rule doesn't apply.
You can see that list in the <a href="https://github.com/model-checking/kani/blob/main/scripts/ci/copyright-exclude">copyright-exclude</a> file.</p>
<h2 id="code-for-soundness"><a class="header" href="#code-for-soundness">Code for soundness</a></h2>
<p>We are developing Kani to provide assurance that critical Rust components are verifiably free of certain classes of
security and correctness issues.
Thus, it is critical that we provide a verification tool that is sound.
For the class of errors that Kani can verify, we should not produce a &quot;No Error&quot; result if there was in fact an
error in the code being verified, i.e., it has no
&quot;False Negatives&quot;.</p>
<p>Because of that, we bias on the side of correctness.
Any incorrect modeling
that may trigger an unsound analysis that cannot be fixed in the short term should be mitigated.
Here are a few ways how we do that.</p>
<h3 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation errors</a></h3>
<p>Make sure to add user-friendly errors for constructs that we can't handle.
For example, Kani cannot handle the panic unwind strategy, and it will fail compilation if the crate uses this
configuration.</p>
<p>In general, it's preferred that error messages follow <a href="https://rustc-dev-guide.rust-lang.org/diagnostics.html#diagnostic-output-style-guide">these guidelines</a> used for <code>rustc</code> development.
If the errors are being emitted from <code>kani-compiler</code>, you should use the compiler error message utilities (e.g., the <code>Session::span_err</code> method). However, if the
errors are being emitted from <code>kani-driver</code>, you should use the functions provided in the <code>util</code> module in <code>kani-driver</code>.</p>
<h3 id="internal-compiler-errors"><a class="header" href="#internal-compiler-errors">Internal compiler errors</a></h3>
<p>Even though this doesn't provide users the best experience, you are encouraged to add checks in the compiler for any
assumptions you make during development.
Those checks can be on the form of <code>assert!()</code> or <code>unreachable!()</code>
statement.
Please provide a meaningful message to help user understand why something failed, and try to explain, at least with 
a comment, why this is the case.</p>
<p>We don't formally use any specific formal representation of <a href="https://en.wikipedia.org/wiki/Design_by_contract">function contract</a>,
but whenever possible we do instrument the code with assertions that may represent the function pre- and
post-conditions to ensure we are modeling the user code correctly.</p>
<h3 id="verification-errors"><a class="header" href="#verification-errors">Verification errors</a></h3>
<p>In cases where Kani fails to model a certain instruction or local construct that doesn't have a global effect,
we encode this failure as a verification error.
I.e., we generate an assertion failure instead of the construct we are modeling using
<a href="https://github.com/model-checking/kani/blob/f719b565968568335d9be03ef27c5d05bb8fd0b7/kani-compiler/src/codegen_cprover_gotoc/utils/utils.rs#L50"><code>codegen_unimplemented()</code></a>,
which blocks the execution whenever this construct is reached.</p>
<p>This will allow users to verify their crate successfully as long as
that construct is not reachable in any harness. If a harness has at least one possible execution path that reaches
such construct, Kani will fail the verification, and it will mark all checks, other than failed checks, with 
<code>UNDETERMINED</code> status.</p>
<h3 id="create-detailed-issues-for-todo-tasks"><a class="header" href="#create-detailed-issues-for-todo-tasks">Create detailed issues for &quot;TODO&quot; tasks</a></h3>
<p>It is OK to add &quot;TODO&quot; comments as long as they don't compromise user experience or the tool correctness.
When doing so, please create an issue that captures the task.
Add details about the task at hand including any impact to the user.
Finally, add the link to the issue that captures the &quot;TODO&quot; task as part of your comment.</p>
<p>E.g.:</p>
<pre><code class="language-rust">// TODO: This function assumes type cannot be ZST. Check if that's always the case.
// https://github.com/model-checking/kani/issues/XXXX
assert!(!typ.is_zst(), &quot;Unexpected ZST type&quot;);
</code></pre>
<h2 id="performant-but-readable"><a class="header" href="#performant-but-readable">Performant but readable</a></h2>
<p>We aim at writing code that is performant but also readable and easy to maintain.
Avoid compromising the code quality if the performance gain is not significant.</p>
<p>Here are few tips that can help the readability of your code:</p>
<ul>
<li>Sort match arms, enum variants, and struct fields alphabetically.</li>
<li>Prefer concise but meaningful names.</li>
<li>Prefer exhaustive matches.</li>
<li>Prefer declarative over imperative programming.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-cbmc"><a class="header" href="#working-with-cbmc">Working with CBMC</a></h1>
<p>This section describes how to access more advanced CBMC options from Kani.</p>
<h2 id="cbmc-arguments"><a class="header" href="#cbmc-arguments">CBMC arguments</a></h2>
<p>Kani is able to handle common CBMC arguments as if they were its own (e.g.,
<code>--default-unwind &lt;n&gt;</code>), but sometimes it may be necessary to use CBMC arguments which
are not handled by Kani.</p>
<p>To pass additional arguments for CBMC, you pass <code>--cbmc-args</code> to Kani. Note that
this &quot;switches modes&quot; from Kani arguments to CBMC arguments: Any arguments that
appear after <code>--cbmc-args</code> are considered to be CBMC arguments, so all Kani
arguments must be placed before it.</p>
<p>Thus, the command line format to invoke <code>cargo kani</code> with CBMC arguments is:</p>
<pre><code class="language-bash">cargo kani [&lt;kani-args&gt;]* --cbmc-args [&lt;cbmc-args&gt;]*
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: In cases where CBMC is not expected to emit a verification output,
you have to use Kani's argument <code>--output-format old</code> to turn off the
post-processing of output from CBMC.</p>
</blockquote>
<h3 id="individual-loop-bounds"><a class="header" href="#individual-loop-bounds">Individual loop bounds</a></h3>
<p>Setting <code>--default-unwind &lt;n&gt;</code> affects every loop in a harness.
Once you know a particular loop is causing trouble, sometimes it can be helpful to provide a specific bound for it.</p>
<p>In the general case, specifying just the highest bound globally for all loops
shouldn't cause any problems, except that the solver may take more time because
<em>all</em> loops will be unwound to the specified bound.</p>
<p>In situations where you need to optimize for the solver, individual bounds for
each loop can be provided on the command line. To do so, we first need to know
the labels assigned to each loop with the CBMC argument <code>--show-loops</code>:</p>
<pre><code># kani src/lib.rs --output-format old --cbmc-args --show-loops
[...]
Loop _RNvCs6JP7pnlEvdt_3lib17initialize_prefix.0:
  file ./src/lib.rs line 11 column 5 function initialize_prefix

Loop _RNvMs8_NtNtCswN0xKFrR8r_4core3ops5rangeINtB5_14RangeInclusivejE8is_emptyCs6JP7pnlEvdt_3lib.0:
  file $RUST/library/core/src/ops/range.rs line 540 column 9 function std::ops::RangeInclusive::&lt;Idx&gt;::is_empty

Loop gen-repeat&lt;[u8; 10]::16806744624734428132&gt;.0:
</code></pre>
<p>This command shows us the labels of the loops involved. Note that, as mentioned
in <a href="cbmc-hacks.html#cbmc-arguments">CBMC arguments</a>, we need to use <code>--output-format old</code> to
avoid post-processing the output from CBMC.</p>
<blockquote>
<p><strong>NOTE</strong>: At the moment, these labels are constructed using the mangled name
of the function and an index. Mangled names are likely to change across
different versions, so this method is highly unstable.</p>
</blockquote>
<p>Then, we can use the CBMC argument <code>--unwindset label_1:bound_1,label_2:bound_2,...</code> to specify an individual bound for each
loop as follows:</p>
<pre><code class="language-bash">kani src/lib.rs --cbmc-args --unwindset _RNvCs6JP7pnlEvdt_3lib17initialize_prefix.0:12
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-rustc"><a class="header" href="#working-with-rustc">Working with <code>rustc</code></a></h1>
<p>Kani is developed on the top of the Rust compiler, which is not distributed on <a href="https://crates.io/">crates.io</a> and depends on
bootstrapping mechanisms to properly build its components.
Thus, our dependency on <code>rustc</code> crates are not declared in our <code>Cargo.toml</code>.</p>
<p>Below are a few hacks that will make it easier to develop on the top of <code>rustc</code>.</p>
<h2 id="code-analysis-for-rustc-definitions"><a class="header" href="#code-analysis-for-rustc-definitions">Code analysis for <code>rustc</code> definitions</a></h2>
<p>IDEs rely on <code>cargo</code> to find dependencies and sources to provide proper code analysis and code completion.
In order to get these features working for <code>rustc</code> crates, you can do the following:</p>
<h3 id="vscode"><a class="header" href="#vscode">VSCode</a></h3>
<p>Add the following to the <code>rust-analyzer</code> extension settings in <code>settings.json</code>:</p>
<pre><code class="language-json">    &quot;rust-analyzer.rustc.source&quot;: &quot;discover&quot;,
    &quot;rust-analyzer.workspace.symbol.search.scope&quot;: &quot;workspace_and_dependencies&quot;,
</code></pre>
<p>Ensure that any packages that use <code>rustc</code> data structures have the following line set in their <code>Cargo.toml</code></p>
<pre><code class="language-toml">[package.metadata.rust-analyzer]
# This package uses rustc crates.
rustc_private=true
</code></pre>
<p>You may also need to install the <code>rustc-dev</code> package using rustup</p>
<pre><code>rustup toolchain install nightly --component rustc-dev
</code></pre>
<h4 id="debugging-in-vs-code"><a class="header" href="#debugging-in-vs-code">Debugging in VS code</a></h4>
<p>To debug Kani in VS code, first install the <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB extension</a>.
Then add the following lines at the start of the <code>main</code> function (see <a href="https://github.com/vadimcn/vscode-lldb/blob/master/MANUAL.md#attaching-debugger-to-the-current-process-rust">the CodeLLDB manual</a> for details):</p>
<pre><code class="language-rust">{
    let url = format!(
        &quot;vscode://vadimcn.vscode-lldb/launch/config?{{'request':'attach','sourceLanguages':['rust'],'waitFor':true,'pid':{}}}&quot;,
        std::process::id()
    );
    std::process::Command::new(&quot;code&quot;).arg(&quot;--open-url&quot;).arg(url).output().unwrap();
}
</code></pre>
<p>Note that pretty printing for the Rust nightly toolchain (which Kani uses) is not very good as of June 2022.
For example, a vector may be displayed as <code>vec![{...}, {...}]</code> on nightly Rust, when it would be displayed as <code>vec![Some(0), None]</code> on stable Rust.
Hopefully, this will be fixed soon.</p>
<h3 id="clion--intellij"><a class="header" href="#clion--intellij">CLion / IntelliJ</a></h3>
<p>This is not a great solution, but it works for now (see <a href="https://github.com/intellij-rust/intellij-rust/issues/1618">https://github.com/intellij-rust/intellij-rust/issues/1618</a>
for more details).
Edit the <code>Cargo.toml</code> of the package that you're working on and add artificial dependencies on the <code>rustc</code> packages that you would like to explore.</p>
<pre><code class="language-toml"># This configuration doesn't exist so it shouldn't affect your build.
[target.'cfg(KANI_DEV)'.dependencies]
# Adjust the path here to point to a local copy of the rust compiler.
# The best way is to use the rustup path. Replace &lt;toolchain&gt; with the
# proper name to your toolchain.
rustc_driver = { path = &quot;~/.rustup/toolchains/&lt;toolchain&gt;/lib/rustlib/rustc-src/rust/compiler/rustc_driver&quot; }
rustc_interface = { path = &quot;~/.rustup/toolchains/&lt;toolchain&gt;/lib/rustlib/rustc-src/rust/compiler/rustc_interface&quot; }
</code></pre>
<p><strong>Don't forget to rollback the changes before you create your PR.</strong></p>
<h3 id="emacs-with-use-package"><a class="header" href="#emacs-with-use-package">EMACS (with <code>use-package</code>)</a></h3>
<p>First, <code>Cargo.toml</code> and <code>rustup toolchain</code> steps are identical to VS
Code. Install Rust-analyzer binary under <code>~/.cargo/bin/</code>.</p>
<p>On EMACS, add the following to your EMACS lisp files. They will
install the necessary packages using the <code>use-package</code> manager.</p>
<pre><code class="language-elisp">;; Install LSP
(use-package lsp-mode
  :commands lsp)
(use-package lsp-ui)

;; Install Rust mode
(use-package toml-mode)
(use-package rust-mode)

(setq lsp-rust-server 'rust-analyzer)
(setenv &quot;PATH&quot; (concat (getenv &quot;PATH&quot;) &quot;:/home/USER/.cargo/bin/&quot;))
</code></pre>
<p>If EMACS complains that it cannot find certain packages, try running
<code>M-x package-refresh-contents</code>.</p>
<p>For LSP to be able to find <code>rustc_private</code> files used by Kani, you
will need to modify variable <code>lsp-rust-analyzer-rustc-source</code>. Run
<code>M-x customize-variable</code>, type in <code>lsp-rust-analyzer-rustc-source</code>,
click <code>Value Menu</code> and change it to <code>Path</code>. Paste in the path to
<code>Cargo.toml</code> of <code>rustc</code>'s source code. You can find the source code
under <code>.rustup</code>, and the path should end with
<code>compiler/rustc/Cargo.toml</code>. <strong>Important</strong>: make sure that this
<code>rustc</code> is the same version and architecture as what Kani uses. If
not, LSP features like definition lookup may be break.</p>
<p>This ends the basic install for EMACS. You can test your configuration
with the following steps.</p>
<ol>
<li>Opening up a rust file with at least one <code>rustc_private</code> import.</li>
<li>Activate LSP mode with <code>M-x lsp</code>.</li>
<li>When asked about the root of the project, pick one of them. <strong>Make
sure</strong> that whichever root you pick has a <code>Cargo.toml</code> with
<code>rustc_private=true</code> added.</li>
<li>If LSP asks if you want to watch all files, select yes. For less
powerful machines, you may want to adjust that later.</li>
<li>On the file with <code>rustc_private</code> imports, do the following. If both
work, then you are set up.
<ul>
<li>Hover mouse over the <code>rustc_private</code> import. If LSP is working,
you should get information about the imported item.</li>
<li>With text cursor over the same <code>rustc_private</code> import, run <code>M-x lsp-find-definition</code>. This should jump to the definition within
<code>rustc</code>'s source code.</li>
</ul>
</li>
</ol>
<p>LSP mode can integrate with <code>flycheck</code> for instant error checking and
<code>company</code> for auto-complete. Consider adding the following to the
configuration.</p>
<pre><code class="language-elisp">(use-package flycheck
  :hook (prog-mode . flycheck-mode))

(use-package company
  :hook (prog-mode . company-mode)
  :config
   (global-company-mode))
</code></pre>
<p><code>clippy</code> linter can be added by changing the LSP install to:</p>
<pre><code class="language-elisp">(use-package lsp-mode
  :commands lsp
  :custom
  (lsp-rust-analyzer-cargo-watch-command &quot;clippy&quot;))
</code></pre>
<p>Finally lsp-mode can run rust-analyzer via TRAMP for remote
development. <strong>We found this way of using rust-analyzer to be unstable
as of 2022-06</strong>. If you want to give it a try you will need to add a
new LSP client for that remote with the following code.</p>
<pre><code class="language-elisp">(lsp-register-client
  (make-lsp-client
	:new-connection (lsp-tramp-connection &quot;/full/path/to/remote/machines/rust-analyzer&quot;)
	:major-modes '(rust-mode)
	:remote? t
	:server-id 'rust-analyzer-remote))
</code></pre>
<p>For further details, please see https://emacs-lsp.github.io/lsp-mode/page/remote/.</p>
<h2 id="custom-rustc"><a class="header" href="#custom-rustc">Custom <code>rustc</code></a></h2>
<p>There are a few reasons why you may want to use your own copy of <code>rustc</code>. E.g.:</p>
<ul>
<li>Enable more verbose logs.</li>
<li>Use a debug build to allow you to step through <code>rustc</code> code.</li>
<li>Test changes to <code>rustc</code>.</li>
</ul>
<p>We will assume that you already have a Kani setup and that the variable <code>KANI_WORKSPACE</code> contains the path to your Kani workspace.</p>
<p><strong>It's highly recommended that you start from the commit that corresponds to the current <code>rustc</code> version from your workspace.</strong>
To get that information, run the following command:</p>
<pre><code class="language-bash">cd ${KANI_WORKSPACE} # Go to your Kani workspace.
rustc --version # This will print the commit id. Something like:
# rustc 1.60.0-nightly (0c292c966 2022-02-08)
#                       ^^^^^^^^^ this is used as the ${COMMIT_ID} below
# E.g.:
COMMIT_ID=0c292c966
</code></pre>
<p>First you need to clone and build stage 2 of the compiler.
You should tweak the configuration to satisfy your use case.
For more details, see <a href="https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html">https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html</a> and <a href="https://rustc-dev-guide.rust-lang.org/building/suggested.html">https://rustc-dev-guide.rust-lang.org/building/suggested.html</a>.</p>
<pre><code class="language-bash">git clone https://github.com/rust-lang/rust.git
cd rust
git checkout ${COMMIT_ID:?&quot;Missing rustc commit id&quot;}
./configure --enable-extended --tools=src,rustfmt,cargo --enable-debug --set=llvm.download-ci-llvm=true
./x.py build -i --stage 2
</code></pre>
<p>Now create a custom toolchain (here we name it <code>custom-toolchain</code>):</p>
<pre><code class="language-bash"># Use x86_64-apple-darwin for MacOs
rustup toolchain link custom-toolchain build/x86_64-unknown-linux-gnu/stage2
cp build/x86_64-unknown-linux-gnu/stage2-tools-bin/* build/x86_64-unknown-linux-gnu/stage2/bin/
</code></pre>
<p>Finally, override the current toolchain in your kani workspace and rebuild kani:</p>
<pre><code class="language-bash">cd ${KANI_WORKSPACE}
rustup override set custom-toolchain
cargo clean
cargo build-dev
</code></pre>
<h1 id="rust-compiler-utilities-to-debug-kani-compiler"><a class="header" href="#rust-compiler-utilities-to-debug-kani-compiler">Rust compiler utilities to debug <code>kani-compiler</code></a></h1>
<h2 id="enable-rustc-logs"><a class="header" href="#enable-rustc-logs">Enable <code>rustc</code> logs</a></h2>
<p>In order to enable logs, you can just define the <code>RUSTC_LOG</code> variable, as documented here: <a href="https://rustc-dev-guide.rust-lang.org/tracing.html">https://rustc-dev-guide.rust-lang.org/tracing.html</a>.</p>
<p>Note that, depending on the level of logs you would like to get (debug and trace are not enabled by default), you'll need to build your own version of <code>rustc</code> as described above.
For logs that are related to <code>kani-compiler</code> code, use the <code>KANI_LOG</code> variable.</p>
<h2 id="debugging-type-layout"><a class="header" href="#debugging-type-layout">Debugging type layout</a></h2>
<p>In order to print the type layout computed by the Rust compiler, you can pass the following flag to <code>rustc</code>: <code>-Zprint-type-sizes</code>.
This flag can be passed to <code>kani</code> or <code>cargo kani</code> by setting the <code>RUSTFLAG</code> environment variable.</p>
<pre><code>RUSTFLAGS=-Zprint-type-sizes kani test.rs
</code></pre>
<p>When enabled, the compiler will print messages that look like:</p>
<pre><code>print-type-size type: `std::option::Option&lt;bool&gt;`: 1 bytes, alignment: 1 bytes
print-type-size     variant `Some`: 1 bytes
print-type-size         field `.0`: 1 bytes
print-type-size     variant `None`: 0 bytes
</code></pre>
<h2 id="inspecting-the-mir"><a class="header" href="#inspecting-the-mir">Inspecting the MIR</a></h2>
<p>You can easily visualize the MIR that is used as an input to code generation by setting the Rust flag <code>--emit mir</code>. I.e.:</p>
<pre><code>RUSTFLAGS=--emit=mir kani test.rs
</code></pre>
<p>The compiler will generate a few files, but we recommend looking at the files that have the following suffix: <code>kani.mir</code>.
Those files will include the entire MIR collected by our reachability analysis.
It will include functions from all dependencies, including the <code>std</code> library.
One limitation is that we dump one copy of each specialization of the MIR function, even though the MIR body itself doesn't change.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transition-to-stablemir"><a class="header" href="#transition-to-stablemir">Transition to StableMIR</a></h1>
<p>We have partnered with the Rust compiler team in the initiative to introduce stable
APIs to the compiler that can be used by third-party tools, which is known as the
<a href="https://github.com/rust-lang/project-stable-mir">Stable MIR Project</a>, or just StableMIR.
This means that we are starting to use the new APIs introduced by this project as is,
despite them not being stable yet.</p>
<h3 id="stablemir-apis"><a class="header" href="#stablemir-apis">StableMIR APIs</a></h3>
<p>For now, the StableMIR APIs are exposed as a crate in the compiler named <code>stable_mir</code>.
This crate includes the definition of structures and methods to be stabilized,
which are expected to become the stable APIs in the compiler.
To reduce the migration burden, these APIs are somewhat close to the original compiler interfaces.
However, some changes have been made to make these APIs cleaner and easier to use.</p>
<p>For example:</p>
<ol>
<li>The usage of the compiler context (aka <code>TyCtxt</code>) is transparent to the user.
The StableMIR implementation caches this context in a thread local variable,
and retrieves it whenever necessary.
<ul>
<li>Because of that, code that uses the StableMIR has to be invoked inside a <code>run</code> call.</li>
</ul>
</li>
<li>The <code>DefId</code> has been specialized into multiple types,
making its usage less error prone. E.g.:
<code>FnDef</code> represents the definition of a function,
while <code>StaticDef</code> is the definition of a static variable.
<ul>
<li>Note that the same <code>DefId</code> may be mapped to different definitions according to its context.
For example, an <code>InstanceDef</code> and a <code>FnDef</code> may represent the same function definition.</li>
</ul>
</li>
<li>Methods that used to be exposed as part of <code>TyCtxt</code> are now part of a type.
Example, the function <code>TyCtxt.instance_mir</code> is now <code>Instance::body</code>.</li>
<li>There is no need for explicit instantiation (monomorphization) of items from an<code>Instance::body</code>.
This method already instantiates all types and resolves all constants before converting
it to stable APIs.</li>
</ol>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>Since the new APIs require converting internal data to a stable representation,
the APIs were also designed to avoid needless conversions,
and to allow extra information to be retrieved on demand.</p>
<p>For example, <code>Ty</code> is just an identifier, while <code>TyKind</code> is a structure that can be retrieved via <code>Ty::kind</code> method.
The <code>TyKind</code> is a more structured object, thus,
it is only generated when the <code>kind</code> method is invoked.
Since this translation is not cached,
many of the functions that the rust compiler used to expose in <code>Ty</code>,
is now only part of <code>TyKind</code>.
The reason being that there is no cache for the <code>TyKind</code>,
and users should do the caching themselves to avoid needless translations.</p>
<p>From our initial experiments with the transition of the reachability algorithm to use StableMIR,
there is a small penalty of using StableMIR over internal rust compiler APIs.
However, they are still fairly efficient and it did not impact the overall compilation time.</p>
<h3 id="interface-with-internal-apis"><a class="header" href="#interface-with-internal-apis">Interface with internal APIs</a></h3>
<p>To reduce the burden of migrating to StableMIR,
and to allow StableMIR to be used together with internal APIs,
there are two helpful methods to convert StableMIR constructs to internal rustc and back:</p>
<ul>
<li><code>rustc_internal::internal()</code>: Convert a Stable item into an internal one.</li>
<li><code>rustc_internal::stable()</code>: Convert an internal item into a Stable one.</li>
</ul>
<p>Both of these methods are inside <code>rustc_smir</code> crate in the <code>rustc_internal</code>
module inside the compiler.
Note that there is no plan to stabilize any of these methods,
and there's also no guarantee on its support and coverage.</p>
<p>The conversion is not implemented for all items, and some conversions may be incomplete.
Please proceed with caution when using these methods.</p>
<p>Besides that, do not invoke any other <code>rustc_smir</code> methods, except for <code>run</code>.
This crate's methods are not meant to be invoked externally.
Note that, the method <code>run</code> will also eventually be replaced by a Stable driver.</p>
<h3 id="creating-and-modifying-stablemir-items"><a class="header" href="#creating-and-modifying-stablemir-items">Creating and modifying StableMIR items</a></h3>
<p>For now, StableMIR should only be used to get information from the compiler.
Do not try to create or modify items directly, as it may not work.
This may result in incorrect behavior or an internal compiler error (ICE).</p>
<h2 id="naming-conventions-in-kani"><a class="header" href="#naming-conventions-in-kani">Naming conventions in Kani</a></h2>
<p>As we adopt StableMIR, we would like to introduce a few conventions to make it easier to maintain the code.
Whenever there is a name conflict, for example, <code>Ty</code> or <code>codegen_ty</code>,
use a suffix to indicate which API you are using.
<code>Stable</code> for StableMIR and <code>Internal</code> for <code>rustc</code> internal APIs.</p>
<p>A module should either default its naming to Stable APIs or Internal APIs.
I.e.: Modules that have been migrated to StableMIR don't need to add the <code>Stable</code> suffix to stable items.
While those that haven't been migrated, should add <code>Stable</code>, but no <code>Internal</code> is needed.</p>
<p>For example, the <code>codegen::typ</code> module will likely include methods:</p>
<p><code>codegen_ty(&amp;mut self, Ty)</code> and <code>codegen_ty_stable(&amp;mut, TyStable)</code> to handle
internal and stable APIs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-cheat-sheets"><a class="header" href="#command-cheat-sheets">Command cheat sheets</a></h1>
<p>Development work in the Kani project depends on multiple tools. Regardless of
your familiarity with the project, the commands below may be useful for
development purposes.</p>
<h2 id="kani"><a class="header" href="#kani">Kani</a></h2>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<pre><code class="language-bash"># Error &quot;'rustc' panicked at 'failed to lookup `SourceFile` in new context'&quot;
# or similar error? Cleaning artifacts might help.
# Otherwise, comment the line below.
cargo clean
cargo build-dev
</code></pre>
<h3 id="test"><a class="header" href="#test">Test</a></h3>
<pre><code class="language-bash"># Full regression suite (does not run bookrunner)
./scripts/kani-regression.sh
</code></pre>
<pre><code class="language-bash"># Delete regression test caches (Linux)
rm -r build/x86_64-unknown-linux-gnu/tests/
</code></pre>
<pre><code class="language-bash"># Delete regression test caches (macOS)
rm -r build/x86_64-apple-darwin/tests/
</code></pre>
<pre><code class="language-bash"># Test suite run (we can only run one at a time)
# cargo run -p compiletest -- --suite ${suite} --mode ${mode}
cargo run -p compiletest -- --suite kani --mode kani
</code></pre>
<pre><code class="language-bash"># Run bookrunner
./scripts/setup/install_bookrunner_deps.sh
cargo run -p bookrunner
</code></pre>
<pre><code class="language-bash"># Build documentation
cd docs
./build-docs.sh
</code></pre>
<h3 id="debug"><a class="header" href="#debug">Debug</a></h3>
<p>These can help understand what Kani is generating or encountering on an example or test file:</p>
<pre><code class="language-bash"># Enable `debug!` macro logging output when running Kani:
kani --debug file.rs
</code></pre>
<pre><code class="language-bash"># Use KANI_LOG for a finer grain control of the source and verbosity of logs.
# E.g.: The command below will print all logs from the kani_middle module.
KANI_LOG=&quot;kani_compiler::kani_middle=trace&quot; kani file.rs
</code></pre>
<pre><code class="language-bash"># Keep CBMC Symbol Table and Goto-C output (.json and .goto)
kani --keep-temps file.rs
</code></pre>
<pre><code class="language-bash"># Generate &quot;C code&quot; from CBMC IR (.c)
kani --gen-c file.rs
</code></pre>
<pre><code class="language-bash"># Generate a ${INPUT}.kani.mir file with a human friendly MIR dump
# for all items that are compiled to the respective goto-program.
RUSTFLAGS=&quot;--emit mir&quot; kani ${INPUT}.rs
</code></pre>
<p>The <code>KANI_REACH_DEBUG</code> environment variable can be used to debug Kani's reachability analysis.
If defined, Kani will generate a DOT graph <code>${INPUT}.dot</code> with the graph traversed during reachability analysis.
If defined and not empty, the graph will be filtered to end at functions that contains the substring
from <code>KANI_REACH_DEBUG</code>.</p>
<p>Note that this will only work on debug builds.</p>
<pre><code class="language-bash"># Generate a DOT graph ${INPUT}.dot with the graph traversed during reachability analysis
KANI_REACH_DEBUG= kani ${INPUT}.rs

# Generate a DOT graph ${INPUT}.dot with the sub-graph traversed during the reachability analysis
# that connect to the given target.
KANI_REACH_DEBUG=&quot;${TARGET_ITEM}&quot; kani ${INPUT}.rs
</code></pre>
<h2 id="cbmc"><a class="header" href="#cbmc">CBMC</a></h2>
<pre><code class="language-bash"># See CBMC IR from a C file:
goto-cc file.c -o file.out
goto-instrument --print-internal-representation file.out
# or (for json symbol table)
cbmc --show-symbol-table --json-ui file.out
# or (an alternative concise format)
cbmc --show-goto-functions file.out
</code></pre>
<pre><code class="language-bash"># Recover C from goto-c binary
goto-instrument --dump-c file.out &gt; file.gen.c
</code></pre>
<h2 id="git"><a class="header" href="#git">Git</a></h2>
<p>The Kani project follows the <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-pull-request-commits">squash and merge option</a> for pull request merges.
As a result:</p>
<ol>
<li>The title of your pull request will become the main commit message.</li>
<li>The messages from commits in your pull request will appear by default as a bulleted list in the main commit message body.</li>
</ol>
<p>But the main commit message body is editable at merge time, so you don't have to worry about &quot;typo fix&quot; messages because these can be removed before merging.</p>
<pre><code class="language-bash"># Set up your git fork
git remote add fork git@github.com:${USER}/kani.git
</code></pre>
<pre><code class="language-bash"># Reset everything. Don't have any uncommitted changes!
git clean -xffd
git submodule foreach --recursive git clean -xffd
git submodule update --init
</code></pre>
<pre><code class="language-bash"># Need to update local branch (e.g. for an open pull request?)
git fetch origin
git merge origin/main
# Or rebase, but that requires a force push,
# and because we squash and merge, an extra merge commit in a PR doesn't hurt.
</code></pre>
<pre><code class="language-bash"># Checkout a pull request locally without the github cli
git fetch origin pull/$ID/head:pr/$ID
git switch pr/$ID
</code></pre>
<pre><code class="language-bash"># Push to someone else's pull request
git origin add $USER $GIR_URL_FOR_THAT_USER
git push $USER $LOCAL_BRANCH:$THEIR_PR_BRANCH_NAME
</code></pre>
<pre><code class="language-bash"># Search only git-tracked files
git grep codegen_panic
</code></pre>
<pre><code class="language-bash"># Accidentally commit to main?
# &quot;Move&quot; commit to a branch:
git checkout -b my_branch
# Fix main:
git branch --force main origin/main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-kani-assess"><a class="header" href="#cargo-kani-assess"><code>cargo kani assess</code></a></h1>
<p>Assess is an experimental new feature to gather data about Rust crates, to aid the start of proof writing.</p>
<p>In the short-term, assess collects and dumps tables of data that may help <em>Kani developers</em> understand what's needed to begin writing proofs for another project.
For instance, assess may help answer questions like:</p>
<ol>
<li>Does Kani successfully build all of the crates involved in this project? If not, why not?</li>
<li>Does Kani support all the Rust language features necessary to do verification with this project? If not, which are most important?</li>
</ol>
<p>In the long-term, assess will become a user-facing feature, and help <em>Kani users</em> get started writing proofs.
We expect that users will have the same questions as above, but in the long term, hopefully the answers to those trend towards an uninteresting &quot;yes.&quot;
So the new questions might be:</p>
<ol start="3">
<li>Is this project ready for verification? Projects need to be reasonably well-tested first.
Our operating hypothesis is that code currently covered by unit tests is the code that could become covered by proofs.</li>
<li>How much of given project (consisting of multiple packages or workspaces) or which of the user's projects might be verifiable?
If a user wants to start trying Kani, but they have the choice of several different packages where they might try, we can help find the package with the lowest hanging fruit.</li>
<li>Given a package, where in that package's code should the user look, in order to write the first (or next) proof?</li>
</ol>
<p>These long-term goals are only &quot;hinted at&quot; with the present experimental version of assess.
Currently, we only get as far as finding out which tests successfully verify (concretely) with Kani.
This might indicate tests that could be generalized and converted into proofs, but we currently don't do anything to group, rank, or otherwise heuristically prioritize what might be most &quot;interesting.&quot;
(For instance, we'd like to eventually compute coverage information and use that to help rank the results.)
As a consequence, the output of the tool is very hard to interpret, and likely not (yet!) helpful to new or potential Kani users.</p>
<h2 id="using-assess"><a class="header" href="#using-assess">Using Assess</a></h2>
<p>To assess a package, run:</p>
<pre><code class="language-text">cargo kani --enable-unstable assess
</code></pre>
<p>As a temporary hack (arguments shouldn't work like this), to assess a single cargo workspace, run:</p>
<pre><code class="language-text">cargo kani --enable-unstable --workspace assess
</code></pre>
<p>To scan a collection of workspaces or packages that are not part of a shared workspace, run:</p>
<pre><code class="language-text">cargo kani --enable-unstable assess scan
</code></pre>
<p>The only difference between 'scan' and 'regular' assess is how the packages built are located.
All versions of assess produce the same output and metrics.
Assess will normally build just like <code>cargo kani</code> or <code>cargo build</code>, whereas <code>scan</code> will find all cargo packages beneath the current directory, even in unrelated workspaces.
Thus, 'scan' may be helpful in the case where the user has a choice of packages and is looking for the easiest to get started with (in addition to the Kani developer use-case, of aggregating statistics across many packages).</p>
<p>(Tip: Assess may need to run for awhile, so try using <code>screen</code>, <code>tmux</code> or <code>nohup</code> to avoid terminating the process if, for example, an ssh connection breaks.
Some tests can also consume huge amounts of ram when run through Kani, so you may wish to use <code>ulimit -v 6000000</code> to prevent any processes from using more than 6GB.
You can also limit the number of concurrent tests that will be run by providing e.g. <code>-j 4</code>, currently as a prepended argument, like <code>--enable-unstable</code> or <code>--workspace</code> in the examples above.)</p>
<h2 id="what-assess-does"><a class="header" href="#what-assess-does">What assess does</a></h2>
<p>Assess builds all the packages requested in &quot;test mode&quot; (i.e. <code>--tests</code>), and runs all the same tests that <code>cargo test</code> would, except through Kani.
This gives end-to-end assurance we're able to actually build and run code from these packages, skipping nothing of what the verification process would need, except that the harnesses don't have any nondeterminism (<code>kani::any()</code>) and consequently don't &quot;prove&quot; much.
The interesting signal comes from what tests cannot be analyzed by Kani due to unsupported features, performance problems, crash bugs, or other issues that get in the way.</p>
<p>Currently, assess forces termination by using <code>unwind(1)</code> on all tests, so many tests will fail with unwinding assertions.</p>
<h2 id="current-assess-results"><a class="header" href="#current-assess-results">Current Assess Results</a></h2>
<p>Assess produces a few tables of output (both visually in the terminal, and in a more detailed json format) so far:</p>
<h3 id="unsupported-features"><a class="header" href="#unsupported-features">Unsupported features</a></h3>
<pre><code class="language-text">======================================================
 Unsupported feature           |   Crates | Instances
                               | impacted |    of use
-------------------------------+----------+-----------
 caller_location               |       71 |       239
 simd_bitmask                  |       39 |       160
...
</code></pre>
<p>The unsupported features table aggregates information about features that Kani does not yet support.
These correspond to uses of <code>codegen_unimplemented</code> in the <code>kani-compiler</code>, and appear as warnings during compilation.</p>
<p>Unimplemented features are not necessarily actually hit by (dynamically) reachable code, so an immediate future improvement on this table would be to count the features <em>actually hit</em> by failing test cases, instead of just those features reported as existing in code by the compiler.
In other words, the current unsupported features table is <strong>not</strong> what we want to see, in order to <em>perfectly</em> prioritize implementing these features, because we may be counting features that no proof would ever hit.
A perfect signal here isn't possible: there may be code that looks statically reachable, but is never dynamically reachable, and we can't tell.
But we can use test coverage as an approximation: well-tested code will hopefully cover most of the dynamically reachable code.
The operating hypothesis of assess is that code covered by tests is code that could be covered by proof, and so measuring unsupported features by those actually hit by a test should provide a better &quot;signal&quot; about priorities.
Implicitly deprioritizing unsupported features because they aren't covered by tests may not be a bug, but a feature: we may simply not want to prove anything about that code, if it hasn't been tested first, and so adding support for that feature may not be important.</p>
<p>A few notes on terminology:</p>
<ol>
<li>&quot;Crates impacted&quot; here means &quot;packages in the current workspace (or scan) where the building of that package (and all of its dependencies) ultimately resulted in this warning.&quot;
For example, if only assessing a single package (not a workspace) this could only be <code>1</code> in this column, regardless of the number of dependencies.</li>
<li>&quot;Instances of use&quot; likewise means &quot;total instances found while compiling this package's tests and all the (reachable) code in its dependencies.&quot;</li>
<li>These counts are influenced by (static) reachability: if code is not potentially reachable from a test somehow, it will not be built and will not be counted.</li>
</ol>
<h3 id="test-failure-reasons"><a class="header" href="#test-failure-reasons">Test failure reasons</a></h3>
<pre><code class="language-text">================================================
 Reason for failure           | Number of tests
------------------------------+-----------------
 unwind                       |              61
 none (success)               |               6
 assertion + overflow         |               2
...
</code></pre>
<p>The test failure reasons table indicates why, when assess ran a test through Kani, it failed to verify.
Notably:</p>
<ol>
<li>Because we force termination with <code>unwind(1)</code>, we expect <code>unwind</code> to rank highly.</li>
<li>We do report number of tests succeeding on this table, to aid understanding how well things went overall.</li>
<li>The reported reason is the &quot;property class&quot; of the CBMC property that failed. So <code>assertion</code> means an ordinary <code>assert!()</code> was hit (or something else with this property class).</li>
<li>When multiple properties fail, they are aggregated with <code>+</code>, such as <code>assertion + overflow</code>.</li>
<li>Currently this table does not properly account for <code>should_fail</code> tests, so <code>assertion</code> may actually be &quot;success&quot;: the test should hit an assertion and did.</li>
</ol>
<h3 id="promising-test-cases"><a class="header" href="#promising-test-cases">Promising test cases</a></h3>
<pre><code class="language-text">=============================================================================
 Candidate for proof harness                           | Location
-------------------------------------------------------+---------------------
 float::tests::f64_edge_cases                          | src/float.rs:226
 float::tests::f32_edge_cases                          | src/float.rs:184
 integer::tests::test_integers                         | src/integer.rs:171
</code></pre>
<p>This table is the most rudimentary so far, but is the core of what long-term assess will help accomplish.
Currently, this table just presents (with paths displayed in a clickable manner) the tests that successfully &quot;verify&quot; with Kani.
These might be good candidates for turning into proof harnesses.
This list is presently unordered; the next step for improving it would be to find even a rudimentary way of ranking these test cases (e.g. perhaps by code coverage).</p>
<h2 id="how-assess-works"><a class="header" href="#how-assess-works">How Assess Works</a></h2>
<p><code>kani-compiler</code> emits <code>*.kani-metadata.json</code> for each target it builds.
This format can be found in the <code>kani_metadata</code> crate, shared by <code>kani-compiler</code> and <code>kani-driver</code>.
This is the starting point for assess.</p>
<p>Assess obtains this metadata by essentially running a <code>cargo kani</code>:</p>
<ol>
<li>With <code>--all-features</code> turned on</li>
<li>With <code>unwind</code> always set to <code>1</code></li>
<li>In test mode, i.e. <code>--tests</code></li>
<li>With test-case reachability mode. Normally Kani looks for proof harnesses and builds only those. Here we switch to building only the test harnesses instead.</li>
</ol>
<p>Assess starts by getting all the information from these metadata files.
This is enough by itself to construct a rudimentary &quot;unsupported features&quot; table.
But assess also uses it to discover all the test cases, and (instead of running proof harnesses) it then runs all these test harnesses under Kani.</p>
<p>Assess produces a second metadata format, called (unsurprisingly) &quot;assess metadata&quot;.
(Found in <code>kani-driver</code> under <a href="https://github.com/model-checking/kani/blob/main/kani-driver/src/assess/metadata.rs"><code>src/assess/metadata.rs</code></a>.)
This format records the results of what assess does.</p>
<p>This metadata can be written to a json file by providing <code>--emit-metadata &lt;file&gt;</code> to <code>assess</code>.
Likewise, <code>scan</code> can be told to write out this data with the same option.</p>
<p>Assess metadata is an aggregatable format.
It does not apply to just one package, as assess can work on a workspace of packages.
Likewise, <code>scan</code> uses and produces the exact same format, across multiple workspaces.</p>
<p>So far all assess metadata comes in the form of &quot;tables&quot; which are built with <code>TableBuilder&lt;T: TableRow&gt;</code>.
This is documented further in <a href="https://github.com/model-checking/kani/blob/main/kani-driver/src/assess/table_builder.rs"><code>src/assess/table_builder.rs</code></a>.</p>
<h2 id="using-assess-on-the-top-100-crates"><a class="header" href="#using-assess-on-the-top-100-crates">Using Assess on the top-100 crates</a></h2>
<p>There is a script in the Kani repo for this purpose.</p>
<p>This will clone the top-100 crates to <code>/tmp/top-100-experiment</code> and run assess scan on them:</p>
<pre><code class="language-text">./scripts/exps/assess-scan-on-repos.sh
</code></pre>
<p>If you'd like to preseve the results, you can direct scan to use a different directory with an environment variable:</p>
<pre><code class="language-text">ASSESS_SCAN=&quot;~/top-100-experiment&quot; ./scripts/exps/assess-scan-on-repos.sh
</code></pre>
<p>To re-run the experiment, it suffices to be in the experiment directory:</p>
<pre><code class="language-text">cd ~/top-100-experiment &amp;&amp; ~/kani/scripts/exps/assess-scan-on-repos.sh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Testing in Kani is carried out in multiple ways. There are at least
two very good reasons to do it:</p>
<ol>
<li>
<p><strong>Software regression</strong>: A regression is a type of bug
that appears after a change is introduced where a feature that
was previously working has unexpectedly stopped working.</p>
<p>Regression testing allows one to prevent a software regression
from happening by running a comprehensive set of working tests
before any change is committed to the project.</p>
</li>
<li>
<p><strong>Software metrics</strong>: A metric is a measure of software
characteristics which are quantitative and countable. Metrics are
particularly valuable for project management purposes.</p>
</li>
</ol>
<p>We recommend reading our section on <a href="./regression-testing.html">Regression
Testing</a> if you're interested in Kani
development. At present, we obtain metrics based on the <a href="./bookrunner.html">book
runner</a>. To run kani on a large number of remotely
hosted crates, please see <a href="./repo-crawl.html">Repository Crawl</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regression-testing"><a class="header" href="#regression-testing">Regression testing</a></h1>
<p>Kani relies on a quite extensive range of tests to perform regression testing.
Regression testing can be executed by running the command:</p>
<pre><code class="language-bash">./scripts/kani-regression.sh
</code></pre>
<p>The <code>kani-regression.sh</code> script executes different testing commands, which we classify into:</p>
<ul>
<li><a href="regression-testing.html#kani-testing-suites">Kani testing suites</a></li>
<li><a href="regression-testing.html#rust-unit-tests">Rust unit tests</a></li>
<li><a href="regression-testing.html#python-unit-tests">Python unit tests</a></li>
<li><a href="regression-testing.html#script-based-tests">Script-based tests</a></li>
</ul>
<p>See below for a description of each one.</p>
<p>Note that regression testing is run whenever a Pull Request is opened, updated or merged
into the main branch. Therefore, it's a good idea to run regression testing locally before
submitting a Pull Request for Kani.</p>
<h2 id="kani-testing-suites"><a class="header" href="#kani-testing-suites">Kani testing suites</a></h2>
<p>The Kani testing suites are the main testing resource for Kani. In most cases, the
tests contained in the Kani testing suites are single Rust files that are run
using the following command:</p>
<pre><code class="language-bash">kani file.rs &lt;options&gt;
</code></pre>
<p>Command-line options can be passed to the test by adding a special
comment to the file. See <a href="regression-testing.html#testing-options">testing options</a> for more details.</p>
<p>In particular, the Kani testing suites are composed of:</p>
<ul>
<li><code>kani</code>: The main testing suite for Kani. The test is a single Rust file that's
run through Kani. In general, the test passes if verification with Kani
is successful, otherwise it fails.</li>
<li><code>firecracker</code>: Works like <code>kani</code> but contains tests inspired by
<a href="https://github.com/firecracker-microvm/firecracker">Firecracker</a> code.</li>
<li><code>prusti</code>: Works like <code>kani</code> but contains tests from the
<a href="https://github.com/viperproject/prusti-dev">Prusti</a> tool.</li>
<li><code>smack</code>: Works like <code>kani</code> but contains tests from the
<a href="https://github.com/smackers/smack">SMACK</a> tool.</li>
<li><code>kani-fixme</code>: Similar to <code>kani</code>, but runs ignored tests from the <code>kani</code> testing
suite (i.e., tests with <code>fixme</code> or <code>ignore</code> in their name).
Allows us to detect when a previously not supported test becomes
supported. More details in <a href="regression-testing.html#fixme-tests">&quot;Fixme&quot; tests</a>.</li>
<li><code>expected</code>: Similar to <code>kani</code> but with an additional check which ensures that
lines appearing in <code>*.expected</code> files appear in the output
generated by <code>kani</code>.</li>
<li><code>ui</code>: Works like <code>expected</code>, but focuses on the user interface (e.g.,
warnings) instead of the verification output.</li>
<li><code>cargo-kani</code>: This suite is designed to test the <code>cargo-kani</code> command. As such,
this suite works with packages instead of single Rust files.
Arguments can be specified in the <code>Cargo.toml</code> configuration file.
Similar to the <code>expected</code> suite, we look for <code>*.expected</code> files
for each harness in the package.</li>
<li><code>cargo-ui</code>: Similar to <code>cargo-kani</code>, but focuses on the user interface like the <code>ui</code> test suite.</li>
<li><code>script-based-pre</code>: This suite is useful to execute script-based tests, and
also allows checking expected output and exit codes after
running them. The suite uses the <code>exec</code> mode, described in
more detail <a href="regression-testing.html#the-exec-mode">here</a>.</li>
</ul>
<p>We've extended
<a href="https://rustc-dev-guide.rust-lang.org/tests/intro.html"><code>compiletest</code></a> (the
Rust compiler testing framework) to work with these suites. That way, we take
advantage of all <code>compiletest</code> features (e.g., parallel execution).</p>
<h3 id="testing-stages"><a class="header" href="#testing-stages">Testing stages</a></h3>
<p>The process of running single-file tests is split into three stages:</p>
<ul>
<li><code>check</code>: This stage uses the Rust front-end to detect if the example is valid
Rust code.</li>
<li><code>codegen</code>: This stage uses the Kani back-end to determine if we can generate
GotoC code.</li>
<li><code>verify</code>: This stage uses CBMC to obtain a verification result.</li>
</ul>
<p>If a test fails, the error message will include the stage where it failed:</p>
<pre><code>error: test failed: expected check success, got failure
</code></pre>
<p>When working on a test that's expected to fail, there are two options to
indicate an expected failure. The first one is to add a comment</p>
<pre><code class="language-rust">// kani-&lt;stage&gt;-fail
</code></pre>
<p>at the top of the test file, where <code>&lt;stage&gt;</code> is the stage where the test is
expected to fail.</p>
<p>The other option is to use the predicate <code>kani::expect_fail(cond, message)</code>
included in the Kani library. The <code>cond</code> in <code>kani::expect_fail</code> is a condition
that you expect not to hold during verification. The testing framework expects
one <code>EXPECTED FAIL</code> message in the verification output for each use of the
predicate.</p>
<blockquote>
<p><strong>NOTE</strong>: <code>kani::expect_fail</code> is only useful to indicate failure in the
<code>verify</code> stage, errors in other stages will be considered testing failures.</p>
</blockquote>
<h3 id="testing-options"><a class="header" href="#testing-options">Testing options</a></h3>
<p>Many tests will require passing command-line options to Kani. These options can
be specified in single Rust files by adding a comment at the top of the file:</p>
<pre><code class="language-rust">// kani-flags: &lt;options&gt;
</code></pre>
<p>For example, to use an unwinding value of 4 in a test, we can write:</p>
<pre><code class="language-rust">// kani-flags: --default-unwind 4
</code></pre>
<p>For <code>cargo-kani</code> tests, the preferred way to pass command-line options is adding
them to <code>Cargo.toml</code>. See <a href="./usage.html#usage-on-a-package"><code>Usage on a package</code></a> for more details.</p>
<h3 id="fixme-tests"><a class="header" href="#fixme-tests">&quot;Fixme&quot; tests</a></h3>
<p>Any test containing <code>fixme</code> or <code>ignore</code> in its name is considered a test not
supported for some reason (i.e., they return an unexpected verification result).</p>
<p>However, &quot;fixme&quot; tests included in the <code>kani</code> folder are run via the <code>kani-fixme</code>
testing suite. <code>kani-fixme</code> works on test files from <code>kani</code> but:</p>
<ol>
<li>Only runs tests whose name contains <code>fixme</code> or <code>ignore</code> (ignoring the rest).</li>
<li>The expected outcome is failure. In other words, a test is successful if it
fails.</li>
</ol>
<p>We welcome contributions with &quot;fixme&quot; tests which demonstrate a bug or
unsupported feature in Kani. Ideally, the test should include some comments
regarding:</p>
<ul>
<li>The expected result of the test.</li>
<li>The actual result of the test (e.g., interesting parts of the output).</li>
<li>Links to related issues.</li>
</ul>
<p>To include a new &quot;fixme&quot; test in <code>kani</code> you only need to ensure its name contains
<code>fixme</code> or <code>ignore</code>. If your changes to Kani cause a &quot;fixme&quot; test to become
supported, you only need to rename it so the name does not contain <code>fixme</code> nor
<code>ignore</code>.</p>
<h2 id="rust-unit-tests"><a class="header" href="#rust-unit-tests">Rust unit tests</a></h2>
<p>These tests follow the
<a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">Rust unit testing</a>
style.</p>
<p>At present, Kani runs unit tests from the following packages:</p>
<ul>
<li><code>cprover_bindings</code></li>
<li><code>kani-compiler</code></li>
<li><code>cargo-kani</code></li>
</ul>
<h2 id="python-unit-tests"><a class="header" href="#python-unit-tests">Python unit tests</a></h2>
<p>We use the Python <a href="https://docs.python.org/3/library/unittest.html">unit testing framework</a> to
test the CBMC JSON parser.</p>
<h2 id="script-based-tests"><a class="header" href="#script-based-tests">Script-based tests</a></h2>
<p>These are tests which are run using scripts. Scripting gives us the ability to
perform ad-hoc checks that cannot be done otherwise. They are currently used
for:</p>
<ul>
<li>Standard library codegen</li>
<li>Firecracker virtio codegen</li>
<li>Diamond dependency</li>
</ul>
<p>In fact, most of them are equivalent to running <code>cargo kani</code> and performing
checks on the output. The downside to scripting is that these tests will always
be run, even if there have not been any changes since the last time the
regression was run.</p>
<blockquote>
<p><strong>NOTE</strong>: With the addition of the <code>exec</code> mode for <code>compiletest</code> (described
below), we'll be migrating these script-based tests to other suites using the
<code>exec</code> mode. The <code>exec</code> mode allows us to take advantage of <code>compiletest</code>
features while executing script-based tests (e.g., parallel execution).</p>
</blockquote>
<h3 id="the-exec-mode"><a class="header" href="#the-exec-mode">The <code>exec</code> mode</a></h3>
<p>The <code>exec</code> mode in <code>compiletest</code> allows us to execute script-based tests, in
addition to checking expected output and exit codes after running them.</p>
<p>In particular, tests are expected to be placed directly under the test directory
(e.g., <code>script-based-pre</code>) in a directory with a <code>config.yml</code> file, which
should contain:</p>
<ul>
<li><code>script</code>: The path to the script to be executed.</li>
<li><code>expected</code> (optional): The path to the <code>.expected</code> file to
use for output comparison.</li>
<li><code>exit_code</code> (optional): The exit code to be returned by executing
the script (a zero exit code is expected if not specified).</li>
</ul>
<p>For example, let's say want to test the script <code>exit-one.sh</code>:</p>
<pre><code class="language-bash">echo &quot;Exiting with code 1!&quot;
exit 1
</code></pre>
<p>In this case, we'll create a folder that contains the <code>config.yml</code> file:</p>
<pre><code class="language-yml">script: exit-one.sh
expected: exit-one.expected
exit_code: 1
</code></pre>
<p>where <code>exit-one.expected</code> is simply a text file such as:</p>
<pre><code class="language-text">Exiting with code 1!
</code></pre>
<p>If <code>expected</code> isn't specified, the output won't be checked. If <code>exit_code</code> isn't
specified, the <code>exec</code> mode will check the exit code was zero.</p>
<p>Note that all paths specified in the <code>config.yml</code> file are local to the test
directory, which is the working directory assumed when executing the test. This
is meant to avoid problems when executing the test manually.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="book-runner"><a class="header" href="#book-runner">Book runner</a></h1>
<p>The <a href="./bookrunner/index.html">book runner</a> is a testing tool based on <a href="https://github.com/awslabs/aws-build-accumulator">Litani</a>.</p>
<p>The purpose of the book runner is to get data about feature coverage in Kani.
To this end, we use Rust code snippet examples from the following general Rust documentation books:</p>
<ul>
<li>The Rust Reference</li>
<li>The Rustonomicon</li>
<li>The Rust Unstable Book</li>
<li>Rust By Example</li>
</ul>
<p>However, not all examples from these books are suited for verification.
For instance, some of them are only included to show what is valid Rust code (or what is not).</p>
<p>Because of that, we run up to three different types of jobs when generating the report:</p>
<ul>
<li><code>check</code> jobs: This check uses the Rust front-end to detect if the example is valid Rust code.</li>
<li><code>codegen</code> jobs: This check uses the Kani back-end to determine if we can generate GotoC code.</li>
<li><code>verification</code> jobs: This check uses CBMC to obtain a verification result.</li>
</ul>
<p>Note that these are incremental: A <code>verification</code> job depends on a previous <code>codegen</code> job.
Similary, a <code>codegen</code> job depends on a <code>check</code> job.</p>
<blockquote>
<p><strong>NOTE</strong>: <a href="https://github.com/awslabs/aws-build-accumulator">Litani</a> does not
support hierarchical views at the moment. For this reason, we are publishing a
<a href="./bookrunner/bookrunner.txt">text version of the book runner report</a> which
displays the same results in a hierarchical way while we work on <a href="https://github.com/model-checking/kani/issues/699">improvements
for the visualization and navigation of book runner
results</a>.</p>
</blockquote>
<p>Before running the above mentioned jobs, we pre-process the examples to:</p>
<ol>
<li>Set the expected output according to flags present in the code snippet.</li>
<li>Add any required compiler/Kani flags (e.g., unwinding).</li>
</ol>
<p>Finally, we run all jobs, collect their outputs and compare them against the expected outputs.
The results are summarized as follows: If the obtained and expected outputs differ,
the color of the stage bar will be red. Otherwise, it will be blue.
If an example shows one red bar, it's considered a failed example that cannot be handled by Kani.</p>
<p>The <a href="./bookrunner/index.html">book runner report</a> and <a href="./bookrunner/bookrunner.txt">its text version</a> are
automatically updated whenever a PR gets merged into Kani.</p>
<h2 id="the-book-running-procedure"><a class="header" href="#the-book-running-procedure">The book running procedure</a></h2>
<p>This section describes how the book runner operates at a high level.</p>
<p>To kick off the book runner process use:</p>
<pre><code class="language-bash">cargo run -p bookrunner
</code></pre>
<p>The main function of the bookrunner is <code>generate_run()</code> (code available
<a href="https://github.com/model-checking/kani/blob/main/tools/bookrunner/src/books.rs">here</a>)
which follows these steps:</p>
<ol>
<li>Sets up all the books, including data about their summaries.</li>
<li>Then, for each book:</li>
</ol>
<ul>
<li>Calls the <code>parse_hierarchy()</code> method to parse its summary
files.</li>
<li>Calls the <code>extract_examples()</code> method to extract all
examples from the book. Note that <code>extract_examples()</code> uses <code>rustdoc</code>
functions to ensure the extracted examples are runnable.</li>
<li>Checks if there is a corresponding <code>.props</code> file
in <code>src/tools/bookrunner/configs/</code>. If there is, prepends the contents of these files
(<a href="./regression-testing.html#testing-options">testing options</a>) to the example.</li>
<li>The resulting examples are written to the <code>src/test/bookrunner/books/</code> folder.</li>
</ul>
<blockquote>
<p>In general, the path to a given example is
<code>src/test/bookrunner/books/&lt;book&gt;/&lt;chapter&gt;/&lt;section&gt;/&lt;subsection&gt;/&lt;line&gt;.rs</code>
where <code>&lt;line&gt;</code> is the line number where the example appears in the markdown
file where it's written. The <code>.props</code> files mentioned above follow the same
naming scheme in order to match them and detect conflicts.</p>
</blockquote>
<ol start="3">
<li>Runs all examples using
<a href="https://github.com/awslabs/aws-build-accumulator">Litani</a> with the
<code>litani_run_tests()</code> function.</li>
<li>Parses the Litani log file with <code>parse_litani_output(...)</code>.</li>
<li>Generates the <a href="./bookrunner/bookrunner.txt">text version of the bookrunner</a>
with <code>generate_text_bookrunner(...)</code>.</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>: Any changes done to the examples in <code>src/test/bookrunner/books/</code> may
be overwritten if the bookrunner is executed.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="experimental-testing-with-a-large-number-of-repositories"><a class="header" href="#experimental-testing-with-a-large-number-of-repositories">(Experimental) Testing with a Large Number of Repositories</a></h1>
<p>This section explains how to run Kani on a large number of crates
downloaded from git forges. You may want to do this if you are going
to test Kani's ability to handle Rust features found in projects out
in the wild.</p>
<p>For the first half, we will explain how to use data from crates.io to
pick targets. Second half will explain how to use a script to run on a
list of selected repositories.</p>
<h2 id="picking-repositories"><a class="header" href="#picking-repositories">Picking Repositories</a></h2>
<p>In picking repositories, you may want to select by metrics like
popularity or by the presence of certain features. In this section, we
will explain how to select top ripostes by download count.</p>
<p>We will use the <code>db-dump</code> method of getting data from crates.io as it
is zero cost to their website and gives us SQL access. To start, have
the following programs set up on your computer.</p>
<ul>
<li>docker</li>
<li>docker-compose.</li>
</ul>
<ol>
<li>Start PostgreSQL. Paste in the following yaml file as
<code>docker-compose.yaml</code>. <code>version: '3.3'</code> may need to change.</li>
</ol>
<pre><code class="language-yaml">version: '3.3'
services:
  db:
    image: postgres:latest
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    volumes:
      - crates-data:/var/lib/postgresql/data
    logging:
      driver: &quot;json-file&quot;
      options:
        max-size: &quot;50m&quot;
volumes:
  crates-data:
    driver: local
</code></pre>
<p>Then, run the following to start the setup.</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<p>Once set up, run <code>docker ls</code> to figure out the container's name. We
will refer to the name as <code>$CONTAINER_NAME</code> from now on.</p>
<ol start="2">
<li>
<p>Download actual data from crates.io. First, run the following
command to get a shell in the container: <code>docker exec -it --user postgres $CONTAINER_NAME bash</code>. Now, run the following to grab and
install the data into the repository. Please note that this may
take a while.</p>
<pre><code class="language-bash">wget https://static.crates.io/db-dump.tar.gz
tar -xf db-dump.tar.gz
psql postgres -f */schema.sql
psql postgres -f */import.sql
</code></pre>
</li>
<li>
<p>Extract the data. In the same docker shell, run the following to
extract the top 1k repositories. Other SQL queries may be used if
you want another criteria</p>
<pre><code class="language-sql">\copy
(SELECT name, repository, downloads  FROM crates
WHERE repository LIKE 'http%' ORDER BY DOWNLOADS DESC LIMIT 1000)
to 'top-1k.csv' csv header;
</code></pre>
</li>
<li>
<p>Clean the data. The above query will capture duplicates paths that
are deeper than the repository. You can clean these out.</p>
<ul>
<li>URL from CSV: <code>cat top-1k.csv | awk -F ',' '{ print $2 }' | grep -v 'http.*'</code></li>
<li>Remove long paths: <code>sed 's/tree\/master.*$//g'</code></li>
<li>Once processed, you can dedup with <code>sort | uniq --unique</code></li>
</ul>
</li>
</ol>
<h2 id="running-the-list-of-repositories"><a class="header" href="#running-the-list-of-repositories">Running the List of Repositories</a></h2>
<p>In this step we will download the list of repositories using a script
<a href="../../scripts/exps/assess-scan-on-repos.sh">assess-scan-on-repos.sh</a></p>
<p>Make sure to have Kani ready to run. For that, see the <a href="cheat-sheets.html#build">build instructions</a>.</p>
<p>From the repository root, you can run the script with
<code>./scripts/exps/assess-scan-on-repos.sh $URL_LIST_FILE</code> where
<code>$URL_LIST_FILE</code> points to a line-delimited list of URLs you want to
run Kani on. Repositories that give warnings or errors can be grepping
for with &quot;STDERR Warnings&quot; and &quot;Error exit in&quot; respectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-comparisons-with-benchcomp"><a class="header" href="#performance-comparisons-with-benchcomp">Performance comparisons with <code>benchcomp</code></a></h1>
<p>While Kani includes a <a href="https://github.com/model-checking/kani/tree/main/tests/perf">performance regression suite</a>, you may wish to test Kani's performance using your own benchmarks or with particular versions of Kani.
You can use the <code>benchcomp</code> tool in the Kani repository to run several 'variants' of a command on one or more benchmark suites; automatically parse the results of each of those suites; and take actions or emit visualizations based on those results.</p>
<h2 id="example-use-cases"><a class="header" href="#example-use-cases">Example use-cases</a></h2>
<ol>
<li>Run one or more benchmark suites with the current and previous versions of Kani.
Exit with a return code of 1 or print a custom summary to the terminal if any benchmark regressed by more than a user-configured amount.</li>
<li>Run benchmark suites using several historical versions of Kani and emit a graph of performance over time.</li>
<li>Run benchmark suites using different SAT solvers, command-line flags, or environment variables.</li>
</ol>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>Benchcomp provides the following features to support your performance-comparison workflow:</p>
<ul>
<li><strong>Automatically copies benchmark suites into a fresh directories</strong> before running with each variant, to ensure that built artifacts do not affect subsequent runtimes</li>
<li><strong>Parses the results of different 'kinds' of benchmark suite</strong> and combines those results into a single unified format.
This allows you to run benchmarks from external repositories, suites of pre-compiled GOTO-binaries, and other kinds of benchmark all together and view their results in a single dashboard.</li>
<li><strong>Driven by a single configuration file</strong> that can be sent to colleagues or checked into a repository to be used in continuous integration.</li>
<li><strong>Extensible,</strong> allowing you to write your own parsers and visualizations.</li>
<li><strong>Caches all previous runs</strong> and allows you to re-create visualizations for the latest run without actually re-running the suites.</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h2>
<p>Here's how to run Kani's performance suite twice, comparing the last released version of Kani with the current HEAD.</p>
<pre><code>cd $KANI_SRC_DIR
git worktree add new HEAD
git worktree add old $(git describe --tags --abbrev=0)

tools/benchcomp/bin/benchcomp --config tools/benchcomp/configs/perf-regression.yaml
</code></pre>
<p>This uses the <a href="https://github.com/model-checking/kani/blob/main/tools/benchcomp/configs/perf-regression.yaml"><code>perf-regression.yaml</code> configuration file</a> that we use in continuous integration.
After running the suite twice, the configuration file terminates <code>benchcomp</code> with a return code of 1 if any of the benchmarks regressed on metrics such as <code>success</code> (a boolean), <code>solver_runtime</code>, and <code>number_vccs</code> (numerical).
Additionally, the config file directs benchcomp to print out a Markdown table that GitHub's CI summary page renders in to a table.</p>
<p>The rest of this documentation describes how to modify <code>benchcomp</code> for your own use cases, including writing a configuration file; writing a custom parser for your benchmark suite; and writing a custom visualization to examine the results of a performance comparison.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchcomp-command-line"><a class="header" href="#benchcomp-command-line"><code>benchcomp</code> command line</a></h1>
<p><code>benchcomp</code> is a single command that runs benchmarks, parses their results, combines these results, and emits visualizations.
<code>benchcomp</code> also provides <em>subcommands</em> to run these steps individually.
Most users will want to invoke <code>benchcomp</code> in one of two ways:</p>
<ul>
<li><code>benchcomp</code> without any subcommands, which runs the entire performance comparison process as depicted below</li>
<li><code>benchcomp visualize</code>, which runs the visualization step on the results of a previous benchmark run without actually re-running the benchmarks.
This is useful when tweaking the parameters of a visualization, for example changing the threshold of what is considered to be a regression.</li>
</ul>
<p>The subcommands <code>run</code> and <code>collate</code> are also available.
The diagram below depicts <code>benchcomp</code>'s order of operation.</p>
<pre><code class="language-dot process">digraph G {
    subgraph cluster_run {
        label=&quot;benchcomp run&quot;;

        suite_1a [label=&quot;suite_1&quot;];
        out_1a [label=&quot;output\nfiles&quot;, shape=box];
        suite_1a -&gt; out_1a [label=&quot;run with\nvariant a&quot;];
        suite_1a_yaml [label=&quot;suite_1a.yaml&quot;, shape=box];
        out_1a -&gt; suite_1a_yaml [label=&quot;suite_1_parser.py&quot;];

        suite_1b [label=&quot;suite_1&quot;];
        out_1b [label=&quot;output\nfiles&quot;, shape=box];
        suite_1b -&gt; out_1b [label=&quot;run with\nvariant b&quot;];
        suite_1b_yaml [label=&quot;suite_1b.yaml&quot;, shape=box];
        out_1b -&gt; suite_1b_yaml [label=&quot;suite_1_parser.py&quot;];

        suite_2c [label=&quot;suite_2&quot;];
        out_2c [label=&quot;output\nfiles&quot;, shape=box];
        suite_2c -&gt; out_2c [label=&quot;run with\nvariant a&quot;];
        suite_2c_yaml [label=&quot;suite_2c.yaml&quot;, shape=box];
        out_2c -&gt; suite_2c_yaml [label=&quot;suite_2_parser.py&quot;];

        suite_2d [label=&quot;suite_2&quot;];
        out_2d [label=&quot;output\nfiles&quot;, shape=box];
        suite_2d -&gt; out_2d [label=&quot;run with\nvariant b&quot;];
        suite_2d_yaml [label=&quot;suite_2d.yaml&quot;, shape=box];
        out_2d -&gt; suite_2d_yaml [label=&quot;suite_2_parser.py&quot;];
    }

    subgraph cluster_collate {
        label=&quot;benchcomp collate&quot;;

        result_yaml [label=&quot;result.yaml&quot;, shape=box];
        suite_2d_yaml -&gt; result_yaml;
        suite_2c_yaml -&gt; result_yaml;
        suite_1b_yaml -&gt; result_yaml;
        suite_1a_yaml -&gt; result_yaml;
    }

    subgraph cluster_vizualize {
        label=&quot;benchcomp visualize&quot;;

        viz_1 [label=&quot;graph.svg&quot;, shape=box];
        viz_2 [label=&quot;summary.md&quot;, shape=box];
        viz_3 [label=&quot;exit 1 on\nregression&quot;, shape=plain];

        result_yaml -&gt; viz_1;
        result_yaml -&gt; viz_2;
        result_yaml -&gt; viz_3;
    }
}
</code></pre>
<p>Running <code>benchcomp</code> invokes <code>run</code>, <code>collate</code>, and <code>visualize</code> behind the scenes.
If you have previously run <code>benchcomp</code>, then running <code>benchcomp visualize</code> will emit the visualizations in the config file using the previous <code>result.yaml</code>.</p>
<p>In the diagram above, two different suites (1 and 2) are both run using two <em>variants</em>---combinations of command, working directory, and environment variables.
Benchmark suite 2 requires a totally different command line to suite 1---for example, <code>suite_1</code> might contain Kani harnesses invoked through <code>cargo kani</code>, while <code>suite_2</code> might contain CBMC harnesses invoked through <code>run_cbmc_proofs.py</code>.
Users would therefore define different variants (<code>c</code> and <code>d</code>) for invoking <code>suite_2</code>, and also specify a different parser to parse the results.
No matter how different the benchmark suites are, the <code>collate</code> stage combines their results so that they can later be compared.</p>
<h2 id="example-config-file"><a class="header" href="#example-config-file">Example config file</a></h2>
<p>Users must specify the actual suites to run, the parsers used to collect their results, and the visualizations to emit in a file called <code>benchcomp.yaml</code> or a file passed to the <code>-c/--config</code> flag.
The <a href="./benchcomp-conf.html">next section</a> describes the schema for this configuration file.
A run similar to the diagram above might be achieved using the following configuration file:</p>
<pre><code class="language-yaml"># Compare a range of Kani and CBMC benchmarks when
# using Cadical versus the default SAT solver

variants:
  variant_a:
    config:
      directory: kani_benchmarks
      command_line: scripts/kani-perf.sh
      env: {}

  variant_b:
    config:
      directory: kani_benchmarks
      command_line: scripts/kani-perf.sh
      # This variant uses a hypothetical environment variable that
      # forces Kani to use the cadical SAT solver
      env:
        KANI_SOLVER: cadical

  variant_c:
    config:
      directory: cbmc_benchmarks
      command_line: run_cbmc_proofs.py
      env: {}

  variant_d:
    config:
      directory: cbmc_benchmarks
      command_line: run_cbmc_proofs.py
      env:
        EXTERNAL_SAT_SOLVER: cadical

run:
  suites:
    suite_1:
      parser:
        module: kani_perf
      variants: [variant_a, variant_b]

    suite_2:
      parser:
        module: cbmc_litani_parser
      variants: [variant_c, variant_d]

visualize:
  - type: dump_graph
    out_file: graph.svg

  - type: dump_markdown_results_table
    out_file: summary.md
    extra_columns: []

  - type: error_on_regression
    variant_pairs:
    - [variant_a, variant_b]
    - [variant_c, variant_d]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchcomp-configuration-file"><a class="header" href="#benchcomp-configuration-file"><code>benchcomp</code> configuration file</a></h1>
<p><code>benchcomp</code>'s operation is controlled through a YAML file---<code>benchcomp.yaml</code> by default or a file passed to the <code>-c/--config</code> option.
This page lists the different visualizations that are available.</p>
<h2 id="built-in-visualizations"><a class="header" href="#built-in-visualizations">Built-in visualizations</a></h2>
<p>The following visualizations are available; these can be added to the <code>visualize</code> list of <code>benchcomp.yaml</code>.</p>
<ul>
<li><a href="benchcomp-conf.html#dump_markdown_results_table">dump_markdown_results_table</a></li>
<li><a href="benchcomp-conf.html#dump_yaml">dump_yaml</a></li>
<li><a href="benchcomp-conf.html#error_on_regression">error_on_regression</a></li>
<li><a href="benchcomp-conf.html#run_command">run_command</a></li>
</ul>
<p>Detailed documentation for these visualizations follows.</p>
<h3 id="dump_markdown_results_table"><a class="header" href="#dump_markdown_results_table">dump_markdown_results_table</a></h3>
<p>Print Markdown-formatted tables displaying benchmark results</p>
<p>For each metric, this visualization prints out a table of benchmarks,
showing the value of the metric for each variant.</p>
<p>The 'out_file' key is mandatory; specify '-' to print to stdout.</p>
<p>'extra_colums' can be an empty dict. The sample configuration below assumes
that each benchmark result has a 'success' and 'runtime' metric for both
variants, 'variant_1' and 'variant_2'. It adds a 'ratio' column to the table
for the 'runtime' metric, and a 'change' column to the table for the
'success' metric. The 'text' lambda is called once for each benchmark. The
'text' lambda accepts a single argument---a dict---that maps variant
names to the value of that variant for a particular metric. The lambda
returns a string that is rendered in the benchmark's row in the new column.
This allows you to emit arbitrary text or markdown formatting in response to
particular combinations of values for different variants, such as
regressions or performance improvements.</p>
<p>Sample configuration:</p>
<pre><code>visualize:
- type: dump_markdown_results_table
  out_file: &quot;-&quot;
  extra_columns:
    runtime:
    - column_name: ratio
      text: &gt;
        lambda b: str(b[&quot;variant_2&quot;]/b[&quot;variant_1&quot;])
        if b[&quot;variant_2&quot;] &lt; (1.5 * b[&quot;variant_1&quot;])
        else &quot;**&quot; + str(b[&quot;variant_2&quot;]/b[&quot;variant_1&quot;]) + &quot;**&quot;
    success:
    - column_name: change
      text: &gt;
        lambda b: &quot;&quot; if b[&quot;variant_2&quot;] == b[&quot;variant_1&quot;]
        else &quot;newly passing&quot; if b[&quot;variant_2&quot;]
        else &quot;regressed&quot;
</code></pre>
<p>Example output:</p>
<pre><code>## runtime

| Benchmark |  variant_1 | variant_2 | ratio |
| --- | --- | --- | --- |
| bench_1 | 5 | 10 | **2.0** |
| bench_2 | 10 | 5 | 0.5 |

## success

| Benchmark |  variant_1 | variant_2 | change |
| --- | --- | --- | --- |
| bench_1 | True | True |  |
| bench_2 | True | False | regressed |
| bench_3 | False | True | newly passing |
</code></pre>
<h3 id="dump_yaml"><a class="header" href="#dump_yaml">dump_yaml</a></h3>
<p>Print the YAML-formatted results to a file.</p>
<p>The 'out_file' key is mandatory; specify '-' to print to stdout.</p>
<p>Sample configuration:</p>
<pre><code>visualize:
- type: dump_yaml
  out_file: '-'
</code></pre>
<h3 id="error_on_regression"><a class="header" href="#error_on_regression">error_on_regression</a></h3>
<p>Terminate benchcomp with a return code of 1 if any benchmark regressed.</p>
<p>This visualization checks whether any benchmark regressed from one variant
to another. Sample configuration:</p>
<pre><code>visualize:
- type: error_on_regression
  variant_pairs:
  - [variant_1, variant_2]
  - [variant_1, variant_3]
  checks:
  - metric: runtime
    test: &quot;lambda old, new: new / old &gt; 1.1&quot;
  - metric: passed
    test: &quot;lambda old, new: False if not old else not new&quot;
</code></pre>
<p>This says to check whether any benchmark regressed when run under variant_2
compared to variant_1. A benchmark is considered to have regressed if the
value of the 'runtime' metric under variant_2 is 10% higher than the value
under variant_1. Furthermore, the benchmark is also considered to have
regressed if it was previously passing, but is now failing. These same
checks are performed on all benchmarks run under variant_3 compared to
variant_1. If any of those lambda functions returns True, then benchcomp
will terminate with a return code of 1.</p>
<h3 id="run_command"><a class="header" href="#run_command">run_command</a></h3>
<p>Run an executable command, passing the performance metrics as JSON on stdin.</p>
<p>This allows you to write your own visualization, which reads a result file
on stdin and does something with it, e.g. writing out a graph or other
output file.</p>
<p>Sample configuration:</p>
<pre><code>visualize:
- type: run_command
  command: ./my_visualization.py
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-parsers"><a class="header" href="#custom-parsers">Custom parsers</a></h1>
<p>Benchcomp ships with built-in <em>parsers</em> that retrieve the results of a benchmark suite after the run has completed.
You can also create your own parser, either to run locally or to check into the Kani codebase.</p>
<h2 id="built-in-parsers"><a class="header" href="#built-in-parsers">Built-in parsers</a></h2>
<p>You specify which parser should run for each benchmark suite in <code>benchcomp.yaml</code>.
For example, if you're running the kani performance suite, you would use the built-in <code>kani_perf</code> parser to parse the results:</p>
<pre><code class="language-yaml">suites:
    my_benchmark_suite:
      variants: [variant_1, variant_2]
      parser:
        module: kani_perf
</code></pre>
<h2 id="custom-parsers-1"><a class="header" href="#custom-parsers-1">Custom parsers</a></h2>
<p>A parser is a program that benchcomp runs inside the root directory of a benchmark suite, after the suite run has completed.
The parser should retrieve the results of the run (by parsing output files etc.) and print the results out as a YAML document.
You can use your executable parser by specifying the <code>command</code> key rather than the <code>module</code> key in your <code>benchconf.yaml</code> file:</p>
<pre><code class="language-yaml">suites:
    my_benchmark_suite:
      variants: [variant_1, variant_2]
      parser:
        command: ./my-cool-parser.sh
</code></pre>
<p>The <code>kani_perf</code> parser mentioned above, in <code>tools/benchcomp/benchcomp/parsers/kani_perf.py</code>, is a good starting point for writing a custom parser, as it also works as a standalone executable.
Here is an example output from an executable parser:</p>
<pre><code class="language-yaml">metrics:
    runtime: {}
    success: {}
    errors: {}
benchmarks:
    bench_1:
        metrics:
            runtime: 32
            success: true
            errors: []
    bench_2:
        metrics:
            runtime: 0
            success: false
            errors: [&quot;compilation failed&quot;]
</code></pre>
<p>The above format is different from the final <code>result.yaml</code> file that benchcomp writes, because the above file represents the output of running a single benchmark suite using a single variant.
Your parser will run once for each variant, and benchcomp combines the dictionaries into the final <code>result.yaml</code> file.</p>
<h2 id="contributing-custom-parsers-to-kani"><a class="header" href="#contributing-custom-parsers-to-kani">Contributing custom parsers to Kani</a></h2>
<p>To turn your executable parser into one that benchcomp can invoke as a module, ensure that it has a <code>main(working_directory)</code> method that returns a dict (the same dict that it would print out as a YAML file to stdout).
Save the file in <code>tools/benchcomp/benchcomp/parsers</code> using python module naming conventions (filename should be an identifier and end in <code>.py</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations-4"><a class="header" href="#limitations-4">Limitations</a></h1>
<p>Like other tools, Kani comes with some limitations. In some cases, these
limitations are inherent because of the techniques it's based on, or the
undecidability of the properties that Kani seeks to prove. In other
cases, it's just a matter of time and effort to remove these limitations (e.g.,
specific unsupported Rust language features).</p>
<p>In this chapter, we do the following to document these limitations:</p>
<ul>
<li>Discuss the effect of <a href="./undefined-behaviour.html">Rust undefined behaviour</a>.</li>
<li>Summarize the <a href="./rust-feature-support.html">current support for Rust features</a>.</li>
<li>Explain the need for <a href="./overrides.html">overrides</a> and list all overriden
symbols.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="undefined-behaviour"><a class="header" href="#undefined-behaviour">Undefined Behaviour</a></h1>
<h2 id="the-effect-of-undefined-behaviour-on-program-verification"><a class="header" href="#the-effect-of-undefined-behaviour-on-program-verification">The Effect of Undefined Behaviour on Program Verification</a></h2>
<p>Rust has a broad definition of <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behaviour</a> (UB).
The <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">Rust documentation warns</a> that UB can have unexpected, non-local effects:</p>
<blockquote>
<p><strong>Note</strong>: Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</p>
</blockquote>
<p>If a program has UB, the semantics of the rest of the program are <strong>undefined</strong>.
As a result, if the program under verification contains UB then, in principle, the program (including its representation in MIR analyzed by Kani) <strong>has no semantics</strong> and hence could do anything, including violating the guarantees checked by Kani. 
This means that verification results are subject to the proviso that the program under verification does not contain UB.</p>
<h2 id="what-forms-of-undefined-behaviour-can-rust-exhibit"><a class="header" href="#what-forms-of-undefined-behaviour-can-rust-exhibit">What forms of Undefined Behaviour can Rust Exhibit</a></h2>
<p>Rust’s <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">definition of UB</a> is so broad that Rust has the following warning:</p>
<blockquote>
<p><strong>Warning</strong>
The following list is not exhaustive. There is no formal model of Rust's semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. The following list is just what we know for sure is undefined behavior. Please read the Rustonomicon (https://doc.rust-lang.org/nomicon/index.html) before writing unsafe code.</p>
</blockquote>
<p>Given the lack of a formal semantics for UB, and given Kani's focus on memory safety, there are classes of UB which Kani does not detect.
A non-exhaustive list of these, based on the non-exhaustive list from the <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">Rust documentation</a>, is:</p>
<ul>
<li>Data races. 
<ul>
<li>Kani focuses on sequential code.</li>
</ul>
</li>
<li>Breaking the pointer aliasing rules (http://llvm.org/docs/LangRef.html#pointer-aliasing-rules). 
<ul>
<li>Kani can detect if misuse of pointers causes memory safety or assertion violations, but does not track reference lifetimes.</li>
</ul>
</li>
<li>Mutating immutable data.
<ul>
<li>Kani can detect if modification of immutable data causes memory safety or assertion violations, but does not track reference lifetimes.</li>
</ul>
</li>
<li>Invoking undefined behavior via compiler intrinsics.
<ul>
<li>Kani makes a best effort attempt to check the preconditions of compiler intrinsics, but does not guarantee to do so in all cases.</li>
</ul>
</li>
<li>Executing code compiled with platform features that the current platform does not support (see <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-target_feature-attribute">target_feature</a>).
<ul>
<li>Kani relies on <code>rustc</code> to check for this case.</li>
</ul>
</li>
<li>Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.
<ul>
<li>Kani relies on <code>rustc</code> to check for this case.</li>
</ul>
</li>
<li>Producing an invalid value, even in private fields and locals. 
<ul>
<li>Kani <a href="./tutorial-nondeterministic-variables.html">won't create invalid values</a> with <code>kani::any()</code> but it also won't complain if you <code>transmute</code> an invalid value to a Rust type (for example, a <code>0</code> to <code>NonZeroU32</code>).</li>
</ul>
</li>
<li>Incorrect use of inline assembly.
<ul>
<li>Kani does not support inline assembly.</li>
</ul>
</li>
<li>Using uninitialized memory.
<ul>
<li>See the corresponding section in our <a href="./rust-feature-support.html#uninitialized-memory">Rust feature support</a>.</li>
</ul>
</li>
</ul>
<p>Kani makes a best-effort attempt to detect some cases of UB:</p>
<ul>
<li>Evaluating a dereference expression (<code>*expr</code>) on a raw pointer that is dangling or unaligned.
<ul>
<li>Kani can detect invalid dereferences, but may not detect them in <a href="https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions">place expression context</a>.</li>
</ul>
</li>
<li>Invoking undefined behavior via compiler intrinsics.
<ul>
<li>See <a href="./rust-feature-support/intrinsics.html">current support for compiler intrinsics</a>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-feature-support"><a class="header" href="#rust-feature-support">Rust feature support</a></h1>
<p>The table below tries to summarize the current support in Kani for
the Rust language features according to the <a href="https://doc.rust-lang.org/stable/reference/">Rust Reference</a>.
We use the following values to indicate the level of support:</p>
<ul>
<li><strong>Yes</strong>: The feature is fully supported. We are not aware of any issue with it.</li>
<li><strong>Partial</strong>: The feature is at least partially supported. We are aware of some issue with
with it.</li>
<li><strong>No</strong>: The feature is not supported. Some support may be available but analyses should not be trusted.</li>
</ul>
<p>As with all software, bugs may be found anywhere regardless of the level of support. In such cases, we
would greatly appreciate that you <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md">filed a bug report</a>.</p>
<table><thead><tr><th>Reference</th><th>Feature</th><th>Support</th><th>Notes</th></tr></thead><tbody>
<tr><td>3.1</td><td>Macros By Example</td><td>Yes</td><td></td></tr>
<tr><td>3.2</td><td>Procedural Macros</td><td>Yes</td><td></td></tr>
<tr><td>4</td><td>Crates and source files</td><td>Yes</td><td></td></tr>
<tr><td>5</td><td>Conditional compilation</td><td>Yes</td><td></td></tr>
<tr><td>6.1</td><td>Modules</td><td>Yes</td><td></td></tr>
<tr><td>6.2</td><td>Extern crates</td><td>Yes</td><td></td></tr>
<tr><td>6.3</td><td>Use declarations</td><td>Yes</td><td></td></tr>
<tr><td>6.4</td><td>Functions</td><td>Yes</td><td></td></tr>
<tr><td>6.5</td><td>Type aliases</td><td>Yes</td><td></td></tr>
<tr><td>6.6</td><td>Structs</td><td>Yes</td><td></td></tr>
<tr><td>6.7</td><td>Enumerations</td><td>Yes</td><td></td></tr>
<tr><td>6.8</td><td>Unions</td><td>Yes</td><td></td></tr>
<tr><td>6.9</td><td>Constant items</td><td>Yes</td><td></td></tr>
<tr><td>6.10</td><td>Static items</td><td>Yes</td><td></td></tr>
<tr><td>6.11</td><td>Traits</td><td>Yes</td><td></td></tr>
<tr><td>6.12</td><td>Implementations</td><td>Yes</td><td></td></tr>
<tr><td>6.13</td><td>External blocks</td><td>Yes</td><td></td></tr>
<tr><td>6.14</td><td>Generic parameters</td><td>Yes</td><td></td></tr>
<tr><td>6.15</td><td>Associated Items</td><td>Yes</td><td></td></tr>
<tr><td>7</td><td>Attributes</td><td>Yes</td><td></td></tr>
<tr><td>8.1</td><td>Statements</td><td>Yes</td><td></td></tr>
<tr><td>8.2.1</td><td>Literal expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.2</td><td>Path expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.3</td><td>Block expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.4</td><td>Operator expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.5</td><td>Grouped expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.6</td><td>Array and index expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.7</td><td>Tuple and index expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.8</td><td>Struct expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.9</td><td>Call expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.10</td><td>Method call expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.11</td><td>Field access expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.12</td><td>Closure expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.13</td><td>Loop expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.14</td><td>Range expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.15</td><td>If and if let expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.16</td><td>Match expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.17</td><td>Return expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.18</td><td>Await expressions</td><td>No</td><td>See <a href="rust-feature-support.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>9</td><td>Patterns</td><td>Partial</td><td><a href="https://github.com/model-checking/kani/issues/707">#707</a></td></tr>
<tr><td>10.1.1</td><td>Boolean type</td><td>Yes</td><td></td></tr>
<tr><td>10.1.2</td><td>Numeric types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.3</td><td>Textual types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.4</td><td>Never type</td><td>Yes</td><td></td></tr>
<tr><td>10.1.5</td><td>Tuple types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.6</td><td>Array types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.7</td><td>Slice types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.8</td><td>Struct types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.9</td><td>Enumerated types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.10</td><td>Union types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.11</td><td>Function item types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.12</td><td>Closure types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.13</td><td>Pointer types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.14</td><td>Function pointer types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.15</td><td>Trait object types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.16</td><td>Impl trait type</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.17</td><td>Type parameters</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.18</td><td>Inferred type</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.2</td><td>Dynamically Sized Types</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.3</td><td>Type layout</td><td>Yes</td><td></td></tr>
<tr><td>10.4</td><td>Interior mutability</td><td>Yes</td><td></td></tr>
<tr><td>10.5</td><td>Subtyping and Variance</td><td>Yes</td><td></td></tr>
<tr><td>10.6</td><td>Trait and lifetime bounds</td><td>Yes</td><td></td></tr>
<tr><td>10.7</td><td>Type coercions</td><td>Partial</td><td>See <a href="rust-feature-support.html#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.8</td><td>Destructors</td><td>Partial</td><td></td></tr>
<tr><td>10.9</td><td>Lifetime elision</td><td>Yes</td><td></td></tr>
<tr><td>11</td><td>Special types and traits</td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>Box&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Rc&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Arc&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Pin&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>UnsafeCell&lt;T&gt;</code></td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>PhantomData&lt;T&gt;</code></td><td>Partial</td><td></td></tr>
<tr><td></td><td>Operator Traits</td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>Deref</code> and <code>DerefMut</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Drop</code></td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>Copy</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Clone</code></td><td>Yes</td><td></td></tr>
<tr><td>14</td><td>Linkage</td><td>Yes</td><td></td></tr>
<tr><td>15.1</td><td>Unsafe functions</td><td>Yes</td><td></td></tr>
<tr><td>15.2</td><td>Unsafe blocks</td><td>Yes</td><td></td></tr>
<tr><td>15.3</td><td>Behavior considered undefined</td><td>Partial</td><td></td></tr>
<tr><td></td><td>Data races</td><td>No</td><td>See <a href="rust-feature-support.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td></td><td>Dereferencing dangling raw pointers</td><td>Yes</td><td></td></tr>
<tr><td></td><td>Dereferencing unaligned raw pointers</td><td>No</td><td></td></tr>
<tr><td></td><td>Breaking pointer aliasing rules</td><td>No</td><td></td></tr>
<tr><td></td><td>Mutating immutable data</td><td>No</td><td></td></tr>
<tr><td></td><td>Invoking undefined behavior via compiler intrinsics</td><td>Partial</td><td>See <a href="rust-feature-support.html#intrinsics">Notes - Intrinsics</a></td></tr>
<tr><td></td><td>Executing code compiled with platform features that the current platform does not support</td><td>No</td><td></td></tr>
<tr><td></td><td>Producing an invalid value, even in private fields and locals</td><td>No</td><td></td></tr>
</tbody></table>
<h2 id="notes-on-partially-or-unsupported-features"><a class="header" href="#notes-on-partially-or-unsupported-features">Notes on partially or unsupported features</a></h2>
<h3 id="code-generation-for-unsupported-features"><a class="header" href="#code-generation-for-unsupported-features">Code generation for unsupported features</a></h3>
<p>Kani aims to be an industrial verification tool. Most industrial crates may
include unsupported features in parts of their code that do not need to be
verified. In general, this should not prevent users using Kani to verify their code.</p>
<p>Because of that, the general rule is that Kani generates an <code>assert(false)</code>
statement followed by an <code>assume(false)</code> statement when compiling any
unsupported feature. <code>assert(false)</code> will cause verification to fail if the
statement is reachable during the verification stage, while <code>assume(false)</code> will
block any further exploration of the path. However, the analysis will not be
affected if the statement is not reachable from the code under verification, so
users can still verify components of their code that do not use unsupported
features.</p>
<p>In a few cases, Kani aborts execution if the analysis could be affected in
some way because of an unsupported feature (e.g., global ASM).</p>
<h3 id="assembly"><a class="header" href="#assembly">Assembly</a></h3>
<p>Kani does not support assembly code for now. We may add it in the future but at
present there are no plans to do so.</p>
<p>Check out the tracking issues for <a href="https://github.com/model-checking/kani/issues/2">inline assembly (<code>asm!</code>
macro)</a> and <a href="https://github.com/model-checking/kani/issues/316">global assembly
(<code>asm_global!</code> macro)</a> to know
more about the current status.</p>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<p>Concurrent features are currently out of scope for Kani. In general, the
verification of concurrent programs continues to be an open research problem
where most tools that analyze concurrent code lack support for other features.
Because of this, Kani emits a warning whenever it encounters concurrent code and
compiles as if it was sequential code.</p>
<h3 id="standard-library-functions"><a class="header" href="#standard-library-functions">Standard library functions</a></h3>
<p>Kani <a href="./overrides.html">overrides</a> a few common functions
(e.g., print macros) to provide a more verification friendly implementation.</p>
<h3 id="advanced-features"><a class="header" href="#advanced-features">Advanced features</a></h3>
<p>The semantics around some advanced features (traits, types, etc.) from Rust are
not formally defined which makes it harder to ensure that we can properly model
all their use cases.</p>
<p>In particular, there are some outstanding issues to note here:</p>
<ul>
<li>Sanity check <code>Variant</code> type in projections
<a href="https://github.com/model-checking/kani/issues/448">#448</a>.</li>
<li>Unexpected fat pointer results in
<a href="https://github.com/model-checking/kani/issues/277">#277</a>,
<a href="https://github.com/model-checking/kani/issues/327">#327</a> and
<a href="https://github.com/model-checking/kani/issues/676">#676</a>.</li>
</ul>
<p>We are particularly interested in bug reports concerning
these features, so please <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md">file a bug
report</a>
if you're aware of one.</p>
<h3 id="panic-strategies"><a class="header" href="#panic-strategies">Panic strategies</a></h3>
<p>Rust has two different strategies when a panic occurs:</p>
<ol>
<li>Stack unwinding (default): Walks back the stack cleaning up the data from
each function it encounters.</li>
<li>Abortion: Immediately ends the program without cleaning up.</li>
</ol>
<p>Currently, Kani does not support stack unwinding. This has some implications
regarding memory safety since programs sometimes rely on the unwinding logic to
ensure there is no resource leak or persistent data inconsistency. Check out
<a href="https://github.com/model-checking/kani/issues/692">this issue</a> for updates on
stack unwinding support.</p>
<h3 id="uninitialized-memory"><a class="header" href="#uninitialized-memory">Uninitialized memory</a></h3>
<p>Reading uninitialized memory is
<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html#behavior-considered-undefined">considered undefined behavior</a> in Rust.
At the moment, Kani cannot detect if memory is uninitialized, but in practice
this is mitigated by the fact that all memory is initialized with
nondeterministic values.
Therefore, any code that depends on uninitialized data will exhibit nondeterministic behavior.
See <a href="https://github.com/model-checking/kani/issues/920">this issue</a> for more details.</p>
<h3 id="destructors"><a class="header" href="#destructors">Destructors</a></h3>
<p>At present, we are aware of some issues with destructors, in particular those
related to <a href="rust-feature-support.html#advanced-features">advanced features</a>.</p>
<h3 id="intrinsics"><a class="header" href="#intrinsics">Intrinsics</a></h3>
<p>Please refer to <a href="rust-feature-support/intrinsics.html">Intrinsics</a> for information
on the current support in Kani for Rust compiler intrinsics.</p>
<h3 id="floating-point-operations"><a class="header" href="#floating-point-operations">Floating point operations</a></h3>
<p>Kani supports floating point numbers, but some supported operations on floats are &quot;over-approximated.&quot;
These are the trigonometric functions like <code>sin</code> and <code>cos</code> and the <code>sqrt</code> function as well.
This means the verifier can raise errors that cannot actually happen when the code is run normally.
For instance, (<a href="https://github.com/model-checking/kani/issues/1342">#1342</a>) the <code>sin</code>/<code>cos</code> functions basically return a nondeterministic value between -1 and 1.
In other words, they largely ignore their input and give very conservative answers.
This range certainly includes the &quot;real&quot; value, so proof soundness is still preserved, but it means Kani could raise spurious errors that cannot actually happen.
This makes Kani unsuitable for verifying some kinds of properties (e.g. precision) about numerical algorithms.
Proofs that fail because of this problem can sometimes be repaired by introducing &quot;stubs&quot; for these functions that return a more acceptable approximation.
However, note that the actual behavior of these functions can vary by platform/os/architecture/compiler, so introducing an &quot;overly precise&quot; approximation may introduce unsoundness: actual system behavior may produce different values from the stub's approximation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intrinsics-1"><a class="header" href="#intrinsics-1">Intrinsics</a></h1>
<p>The tables below try to summarize the current support in Kani for Rust intrinsics.
We define the level of support similar to how we indicate <a href="rust-feature-support/../rust-feature-support.html">Rust feature support</a>:</p>
<ul>
<li><strong>Yes</strong>: The intrinsic is fully supported. We are not aware of any issue with it.</li>
<li><strong>Partial</strong>: The intrinsic is at least partially supported. We are aware of some issue with
with it.</li>
<li><strong>No</strong>: The intrinsic is not supported.</li>
</ul>
<p>In general, code generation for unsupported intrinsics follows the rule
described in <a href="rust-feature-support/../rust-feature-support.html#code-generation-for-unsupported-features">Rust feature support - Code generation for unsupported
features</a>.</p>
<p>Any intrinsic not appearing in the tables below is considered not supported.
Please <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=%5BC%5D+Feature+%2F+Enhancement&amp;template=feature_request.md&amp;title=">open a feature request</a>
if your code depends on an unsupported intrinsic.</p>
<h3 id="compiler-intrinsics"><a class="header" href="#compiler-intrinsics">Compiler intrinsics</a></h3>
<table><thead><tr><th>Name</th><th>Support</th><th>Notes</th></tr></thead><tbody>
<tr><td>abort</td><td>Yes</td><td></td></tr>
<tr><td>add_with_overflow</td><td>Yes</td><td></td></tr>
<tr><td>arith_offset</td><td>Yes</td><td></td></tr>
<tr><td>assert_inhabited</td><td>Yes</td><td></td></tr>
<tr><td>assert_uninit_valid</td><td>Yes</td><td></td></tr>
<tr><td>assert_zero_valid</td><td>Yes</td><td></td></tr>
<tr><td>assume</td><td>Yes</td><td></td></tr>
<tr><td>atomic_and_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acqrel_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acqrel_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acqrel_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acquire_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acquire_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acquire_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_relaxed_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_relaxed_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_relaxed_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_release_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_release_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_release_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_seqcst_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_seqcst_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_seqcst_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acqrel_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acqrel_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acqrel_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acquire_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acquire_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acquire_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_relaxed_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_relaxed_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_relaxed_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_release_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_release_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_release_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_seqcst_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_seqcst_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_seqcst_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_unordered</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_unordered</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_seqcst</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_acquire</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_acqrel</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_release</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_relaxed</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#atomics">Atomics</a></td></tr>
<tr><td>blackbox</td><td>Yes</td><td></td></tr>
<tr><td>bitreverse</td><td>Yes</td><td></td></tr>
<tr><td>breakpoint</td><td>Yes</td><td></td></tr>
<tr><td>bswap</td><td>Yes</td><td></td></tr>
<tr><td>caller_location</td><td>No</td><td></td></tr>
<tr><td>ceilf32</td><td>Yes</td><td></td></tr>
<tr><td>ceilf64</td><td>Yes</td><td></td></tr>
<tr><td>copy</td><td>Yes</td><td></td></tr>
<tr><td>copy_nonoverlapping</td><td>Yes</td><td></td></tr>
<tr><td>copysignf32</td><td>Yes</td><td></td></tr>
<tr><td>copysignf64</td><td>Yes</td><td></td></tr>
<tr><td>cosf32</td><td>Partial</td><td>Results are overapproximated; <a href="https://github.com/model-checking/kani/blob/main/tests/kani/Intrinsics/Math/Trigonometry/cosf32.rs">this test</a> explains how</td></tr>
<tr><td>cosf64</td><td>Partial</td><td>Results are overapproximated; <a href="https://github.com/model-checking/kani/blob/main/tests/kani/Intrinsics/Math/Trigonometry/cosf64.rs">this test</a> explains how</td></tr>
<tr><td>ctlz</td><td>Yes</td><td></td></tr>
<tr><td>ctlz_nonzero</td><td>Yes</td><td></td></tr>
<tr><td>ctpop</td><td>Yes</td><td></td></tr>
<tr><td>cttz</td><td>Yes</td><td></td></tr>
<tr><td>cttz_nonzero</td><td>Yes</td><td></td></tr>
<tr><td>discriminant_value</td><td>Yes</td><td></td></tr>
<tr><td>drop_in_place</td><td>No</td><td></td></tr>
<tr><td>exact_div</td><td>Yes</td><td></td></tr>
<tr><td>exp2f32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>exp2f64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>expf32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>expf64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>fabsf32</td><td>Yes</td><td></td></tr>
<tr><td>fabsf64</td><td>Yes</td><td></td></tr>
<tr><td>fadd_fast</td><td>Yes</td><td></td></tr>
<tr><td>fdiv_fast</td><td>Partial</td><td><a href="https://github.com/model-checking/kani/issues/809">#809</a></td></tr>
<tr><td>float_to_int_unchecked</td><td>No</td><td></td></tr>
<tr><td>floorf32</td><td>Yes</td><td></td></tr>
<tr><td>floorf64</td><td>Yes</td><td></td></tr>
<tr><td>fmaf32</td><td>No</td><td></td></tr>
<tr><td>fmaf64</td><td>No</td><td></td></tr>
<tr><td>fmul_fast</td><td>Partial</td><td><a href="https://github.com/model-checking/kani/issues/809">#809</a></td></tr>
<tr><td>forget</td><td>Yes</td><td></td></tr>
<tr><td>frem_fast</td><td>No</td><td></td></tr>
<tr><td>fsub_fast</td><td>Yes</td><td></td></tr>
<tr><td>likely</td><td>Yes</td><td></td></tr>
<tr><td>log10f32</td><td>No</td><td></td></tr>
<tr><td>log10f64</td><td>No</td><td></td></tr>
<tr><td>log2f32</td><td>No</td><td></td></tr>
<tr><td>log2f64</td><td>No</td><td></td></tr>
<tr><td>logf32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>logf64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>maxnumf32</td><td>Yes</td><td></td></tr>
<tr><td>maxnumf64</td><td>Yes</td><td></td></tr>
<tr><td>min_align_of</td><td>Yes</td><td></td></tr>
<tr><td>min_align_of_val</td><td>Yes</td><td></td></tr>
<tr><td>minnumf32</td><td>Yes</td><td></td></tr>
<tr><td>minnumf64</td><td>Yes</td><td></td></tr>
<tr><td>move_val_init</td><td>No</td><td></td></tr>
<tr><td>mul_with_overflow</td><td>Yes</td><td></td></tr>
<tr><td>nearbyintf32</td><td>Yes</td><td></td></tr>
<tr><td>nearbyintf64</td><td>Yes</td><td></td></tr>
<tr><td>needs_drop</td><td>Yes</td><td></td></tr>
<tr><td>nontemporal_store</td><td>No</td><td></td></tr>
<tr><td>offset</td><td>Partial</td><td>Doesn't check <a href="https://doc.rust-lang.org/std/primitive.pointer.html#safety-2">all UB conditions</a></td></tr>
<tr><td>powf32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>powf64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>powif32</td><td>No</td><td></td></tr>
<tr><td>powif64</td><td>No</td><td></td></tr>
<tr><td>pref_align_of</td><td>Yes</td><td></td></tr>
<tr><td>prefetch_read_data</td><td>No</td><td></td></tr>
<tr><td>prefetch_read_instruction</td><td>No</td><td></td></tr>
<tr><td>prefetch_write_data</td><td>No</td><td></td></tr>
<tr><td>prefetch_write_instruction</td><td>No</td><td></td></tr>
<tr><td>ptr_guaranteed_eq</td><td>Yes</td><td></td></tr>
<tr><td>ptr_guaranteed_ne</td><td>Yes</td><td></td></tr>
<tr><td>ptr_offset_from</td><td>Partial</td><td>Doesn't check <a href="https://doc.rust-lang.org/std/primitive.pointer.html#safety-4">all UB conditions</a></td></tr>
<tr><td>raw_eq</td><td>Partial</td><td>Cannot detect <a href="rust-feature-support/intrinsics.html#uninitialized-memory">uninitialized memory</a></td></tr>
<tr><td>rintf32</td><td>Yes</td><td></td></tr>
<tr><td>rintf64</td><td>Yes</td><td></td></tr>
<tr><td>rotate_left</td><td>Yes</td><td></td></tr>
<tr><td>rotate_right</td><td>Yes</td><td></td></tr>
<tr><td>roundf32</td><td>Yes</td><td></td></tr>
<tr><td>roundf64</td><td>Yes</td><td></td></tr>
<tr><td>rustc_peek</td><td>No</td><td></td></tr>
<tr><td>saturating_add</td><td>Yes</td><td></td></tr>
<tr><td>saturating_sub</td><td>Yes</td><td></td></tr>
<tr><td>sinf32</td><td>Partial</td><td>Results are overapproximated; <a href="https://github.com/model-checking/kani/blob/main/tests/kani/Intrinsics/Math/Trigonometry/sinf32.rs">this test</a> explains how</td></tr>
<tr><td>sinf64</td><td>Partial</td><td>Results are overapproximated; <a href="https://github.com/model-checking/kani/blob/main/tests/kani/Intrinsics/Math/Trigonometry/sinf64.rs">this test</a> explains how</td></tr>
<tr><td>size_of</td><td>Yes</td><td></td></tr>
<tr><td>size_of_val</td><td>Yes</td><td></td></tr>
<tr><td>sqrtf32</td><td>No</td><td></td></tr>
<tr><td>sqrtf64</td><td>No</td><td></td></tr>
<tr><td>sub_with_overflow</td><td>Yes</td><td></td></tr>
<tr><td>transmute</td><td>Partial</td><td>Doesn't check <a href="https://doc.rust-lang.org/nomicon/transmutes.html">all UB conditions</a></td></tr>
<tr><td>truncf32</td><td>Yes</td><td></td></tr>
<tr><td>truncf64</td><td>Yes</td><td></td></tr>
<tr><td>try</td><td>No</td><td><a href="https://github.com/model-checking/kani/issues/267">#267</a></td></tr>
<tr><td>type_id</td><td>Yes</td><td></td></tr>
<tr><td>type_name</td><td>Yes</td><td></td></tr>
<tr><td>unaligned_volatile_load</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>unaligned_volatile_store</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>unchecked_add</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_div</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_mul</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_rem</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_shl</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_shr</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_sub</td><td>Yes</td><td></td></tr>
<tr><td>unlikely</td><td>Yes</td><td></td></tr>
<tr><td>unreachable</td><td>Yes</td><td></td></tr>
<tr><td>variant_count</td><td>No</td><td></td></tr>
<tr><td>volatile_copy_memory</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_copy_nonoverlapping_memory</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_load</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_set_memory</td><td>No</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_store</td><td>Partial</td><td>See <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>wrapping_add</td><td>Yes</td><td></td></tr>
<tr><td>wrapping_mul</td><td>Yes</td><td></td></tr>
<tr><td>wrapping_sub</td><td>Yes</td><td></td></tr>
<tr><td>write_bytes</td><td>Yes</td><td></td></tr>
</tbody></table>
<h4 id="atomics"><a class="header" href="#atomics">Atomics</a></h4>
<p>All atomic intrinsics are compiled as an atomic block where the operation is
performed. But as noted in <a href="rust-feature-support/intrinsics.html#concurrency">Notes - Concurrency</a>, Kani support for
concurrent verification is limited and not used by default. Verification on code
containing atomic intrinsics should not be trusted given that Kani assumes the
code to be sequential.</p>
<h3 id="platform-intrinsics"><a class="header" href="#platform-intrinsics">Platform intrinsics</a></h3>
<p>Intrinsics from <a href="https://rust-lang.github.io/rfcs/1199-simd-infrastructure.html#operations">the <code>platform_intrinsics</code> feature</a>.</p>
<table><thead><tr><th>Name</th><th>Support</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>simd_add</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_and</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_div</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_eq</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_extract</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_ge</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_gt</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_insert</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_le</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_lt</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_mul</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_ne</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_or</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_rem</code></td><td>Yes</td><td>Doesn't check for floating point overflow <a href="https://github.com/model-checking/kani/issues/2669">#2669</a></td></tr>
<tr><td><code>simd_shl</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_shr</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_shuffle*</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_sub</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_xor</code></td><td>Yes</td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unstable-features"><a class="header" href="#unstable-features">Unstable features</a></h1>
<p>In general, unstable Rust features are out of scope and any support
for them available in Kani should be considered unstable as well.</p>
<p>The following are examples of unstable features that are not supported
in Kani:</p>
<ul>
<li>Generators</li>
<li>C-variadics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overrides"><a class="header" href="#overrides">Overrides</a></h1>
<p>As explained in <a href="./tool-comparison.html#comparison-with-other-tools">Comparison with other
tools</a>, Kani is based on a
technique called model checking, which verifies a program without actually
executing it. It does so through encoding the program and analyzing the encoded
version. The encoding process often requires &quot;modeling&quot; some of the library
functions to make them suitable for analysis. Typical examples of functionality
that requires modeling are system calls and I/O operations. In some cases, Kani
performs such encoding through overriding some of the definitions in the Rust
standard library.</p>
<p>The following table lists some of the symbols that Kani
overrides and a description of their behavior compared to the <code>std</code> versions:</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assert</code>, <code>assert_eq</code>, and <code>assert_ne</code> macros</td><td>Skips string formatting code, generates a more informative message and performs some instrumentation</td></tr>
<tr><td><code>debug_assert</code>, <code>debug_assert_eq</code>, and <code>debug_assert_ne</code> macros</td><td>Rewrites as equivalent <code>assert*</code> macro</td></tr>
<tr><td><code>print</code>, <code>eprint</code>, <code>println</code>, and <code>eprintln</code> macros</td><td>Skips string formatting and I/O operations</td></tr>
<tr><td><code>unreachable</code> macro</td><td>Skips string formatting and invokes <code>panic!()</code></td></tr>
<tr><td><code>std::process::{abort, exit}</code> functions</td><td>Invokes <code>panic!()</code> to abort the execution</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates-documentation"><a class="header" href="#crates-documentation">Crates documentation</a></h1>
<p>Kani currently ships with a <code>kani</code> crate that provide APIs to allow users to
write and configure their harnesses.
These APIs are tightly coupled with each Kani version, so they are not
published yet at <a href="https://crates.io">https://crates.io</a>.</p>
<p>You can find their latest documentation here:</p>
<ul>
<li><a href="https://model-checking.github.io/kani/crates/doc/kani">kani</a>: This crate
provide APIs to write Kani harnesses.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faqs"><a class="header" href="#faqs">FAQs</a></h1>
<p>This section collects frequently asked questions about Kani.
Please consider <a href="https://github.com/model-checking/kani/issues/new/choose">opening an issue</a> if you have a question that would like to see here.</p>
<h2 id="questions"><a class="header" href="#questions">Questions</a></h2>
<details>
<summary>Kani doesn't fail after <code>kani::assume(false)</code>. Why?</summary>
</br>
<p><code>kani::assume(false)</code> (or <code>kani::assume(cond)</code> where <code>cond</code> is a condition that results in <code>false</code> in the context of the program), won't cause errors in Kani.
Instead, such an assumption has the effect of blocking all the symbolic execution paths from the assumption.
Therefore, all checks after the assumption should appear as <a href="faq.html#../../verification-results.md"><code>UNREACHABLE</code></a>.
That's the expected behavior for <code>kani::assume(false)</code> in Kani.</p>
<p>If you didn't expect certain checks in a harness to be <code>UNREACHABLE</code>, we recommend using the <a href="faq.html#../../verification-results.md#cover-property-results"><code>kani::cover</code> macro</a> to determine what conditions are possible in case you've over-constrained the harness.</p>
</details>
<details>
<summary>I implemented the <code>kani::Arbitrary</code> trait for a type that's not from my crate, and got the error
<code>only traits defined in the current crate can be implemented for types defined outside of the crate</code>.
What does this mean? What can I do?</summary>
</br>
<p>This error is due to a violation of Rust's orphan rules for trait implementations, which are explained <a href="https://doc.rust-lang.org/error_codes/E0117.html">here</a>.
In that case, you'll need to write a function that builds an object from non-deterministic variables.
Inside this function you would simply return an arbitrary value by generating arbitrary values for its components.</p>
<p>For example, let's assume the type you're working with is this enum:</p>
<pre><code class="language-rust">#[derive(Copy, Clone)]
pub enum Rating {
    One,
    Two,
    Three,
}
</code></pre>
<p>Then, you can match on a non-deterministic integer (supplied by <code>kani::any</code>) to return non-deterministic <code>Rating</code> variants:</p>
<pre><code class="language-rust">    pub fn any_rating() -&gt; Rating {
        match kani::any() {
            0 =&gt; Rating::One,
            1 =&gt; Rating::Two,
            _ =&gt; Rating::Three,
        }
    }
</code></pre>
<p>More details about this option, which also useful in other cases, can be found <a href="https://model-checking.github.io/kani/tutorial-nondeterministic-variables.html#custom-nondeterministic-types">here</a>.</p>
<p>If the type comes from <code>std</code> (Rust's standard library), you can <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=%5BC%5D+Feature+%2F+Enhancement&amp;template=feature_request.md&amp;title=">open a request</a> for adding <code>Arbitrary</code> implementations to the Kani library.
Otherwise, there are more involved options to consider:</p>
<ol>
<li>Importing a copy of the external crate that defines the type, then implement <code>Arbitrary</code> there.</li>
<li>Contributing the <code>Arbitrary</code> implementation to the external crate that defines the type.</li>
</ol>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
